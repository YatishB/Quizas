<!DOCTYPE html>
<html>
 <head>
	<meta name="viewport" content="width=device-width, user-scalable=no" />
	<title></title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src='http://cdn.html5quintus.com/v0.2.0/quintus-all.js'></script>
	<script src='http://cdnjs.cloudflare.com/ajax/libs/socket.io/0.9.16/socket.io.min.js'></script>
	<script src='js/quizas_auth_helper.js'></script>

    <!-- <script src='example1.js'></script> -->
	<link rel="stylesheet" type="text/css" href="css/singlePlayer.css">
	<script src="js/socketinit.js" />
	<script>
		</script>
 </head>
 
 <body>
	<script>
		// socket stuff
	/*
			namespace = '/test'; // change to an empty string to use the global namespace

            // the socket.io documentation recommends sending an explicit package upon connection
            // this is specially important when using the global namespace
            var socket = io.connect('http://' + document.domain + ':' + location.port + namespace,
                                    {"connect timeout": 300,
                                     "close timeout": 30,
                                     "hearbeat timeout": 30});
            socket.on('connect', function() {
            });
			
			 
		
		// socket handler
		socket.on('initiating', function(msg) {
                //$('#log').append('<br>Received #' + msg.count + ': ' + msg.data);
            });
	*/
		
	
		// helper functions
		
		String.prototype.insert = function (index, string) {
			  if (index > 0)
				return this.substring(0, index) + string + this.substring(index, this.length);
			  else
				return string + this;
			};
		
		function wordWrap(iStr, cardWidth, pixelPerChar) {
			var wrappedStr = iStr;
			var n = iStr.length;
			
			if ((n * pixelPerChar) > cardWidth) {
				var m = Math.floor((n * pixelPerChar)/cardWidth);
				for (i=0;i<m;i++) {
					wrappedStr = wrappedStr.insert((i+1)*(cardWidth/pixelPerChar), "\n");
				}
			}
			
			return wrappedStr;
		}
		
		function Countdown(options) {
			var timer,
			  instance = this,
			  seconds = options.seconds || 10,
			  updateStatus = options.onUpdateStatus || function () {},
			  counterEnd = options.onCounterEnd || function () {},
			  offset, max;
			  
			function decrementCounter() {
				d = delta();
				seconds = (seconds >= d) ? seconds -= d : 0;
				updateStatus((seconds/1000).toFixed(2));
				if (seconds <= 0) {
					counterEnd();
					instance.stop();
				}
			}
			
			function delta() {
				var now = Date.now(),
				  d = now - offset;
				offset = now;
				return d;
			}
			
			this.getTime = function() {
				return (max - seconds);
			};

			this.start = function () {
				clearInterval(timer);
				timer = 0;
				offset = Date.now();
				max = options.seconds * 1000;
				seconds = options.seconds * 1000;
				timer = setInterval(decrementCounter, 10);
			};

			 this.stop = function () {
				clearInterval(timer);
			};
		}
	
		function parseBool(param) {
			return (param === 'true');
		}
		
		function createFlashCard(pId, pQn, pAns) {
			var fc = JSON.stringify({
				id: pId, 
				question: pQn, 
				answer: pAns, 
			});
			return fc;
		}
		
		function createFlashSet(pId, pN, pC, pFc) {
			var fs = JSON.stringify({
				id: pId,
				name: pN,
				category: pC,
				cards: pFc
			});
			return fs;
		}
		
		function getFlashCard(flashSet, n) { // input fs and output fc all in JSON
			var fs = JSON.parse(flashSet);
			var fc = fs.cards[n];
			return fc;
		}
		
		function getDeckSize(flashSet) { // input in JSON, output in integer
			var parsedDeck = JSON.parse(flashSet);
			var n = parsedDeck.cards.length;
			return n;
		}
		
		function shuffle(array) { // http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
			var currentIndex = array.length, temporaryValue, randomIndex ;

			// While there remain elements to shuffle...
			while (0 !== currentIndex) {

				// Pick a remaining element...
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex -= 1;

				// And swap it with the current element.
				temporaryValue = array[currentIndex];
				array[currentIndex] = array[randomIndex];
				array[randomIndex] = temporaryValue;
			}

		return array;
		}
		
		/**
		 * Returns a random integer between min (inclusive) and max (inclusive)
		 * Using Math.round() will give you a non-uniform distribution!
		 */
		function getRandomInt(min, max) {
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}
		
		function shuffleDeck(x, n) { // x = decksize, n = totalsize
			var deck = [];
			for (i=0;i<n;i++) {
				deck[i] = i;
			}
			var newDeck = shuffle(deck);
			var chosenDeck = newDeck.slice(0, x);
			return chosenDeck;
		}
		
		function dealAnswers(a, n) { // a = order # of answer, n = decksize
			var deck = [];
			var iniCounter = 0;
			for (i=0;i<n;i++) {
				if (i != a) {
					deck[iniCounter] = i;
					iniCounter = iniCounter + 1;
				}
			}
			var newDeck = shuffle(deck);
			var chosenDeck = newDeck.slice(0, 3);
			var finalDeck = [];
			var hasInserted = false;
			var deckCounter = 0;
			for (i=0;i<4;i++) {
				var decision = Math.random() < 0.5;
				if (!hasInserted && (decision || i == 3)) {
					finalDeck[i] = a;
					hasInserted = true;
				} else {
					finalDeck[i] = chosenDeck[deckCounter];
					deckCounter = deckCounter + 1;
				}
			}
			return finalDeck;
		}
		
		function createClientToServerJSON(questionId, answerId, timeTaken, questionsCompleted) {
			var clientJSON = JSON.stringify({
				id: questionId,
				answer: answerId,
				time: timeTaken,
				done: questionsCompleted,
			});
			return clientJSON;
		}
		
		// some global variables
		var playerCounters = [];
		var enemyCounters = [];

		// declare JSON vars for testing purposes
		var TestFlashCard = createFlashCard('22', 'F=??', 'M x A');
		
		var TestFCArray = [];
		for (i=0;i<30;i++) {
			var stringId = i.toString();
			var stringQn = i.toString() + ' + ' + i.toString() + ' = ??';
			var stringAns = (i + i).toString();
			var fc = createFlashCard(stringId, stringQn, stringAns);
			TestFCArray[i] = fc;
		}
		var TestFlashSet = createFlashSet('101', 'Simple Additions', 'Mathematics', TestFCArray);
		var TestTotalQuestions = 10;
		
		var TestInitiatingForm = JSON.stringify({
			name: "John Smith",
			sprite: "smiley.png",
			win: "75%",
			encounter: "6",
			total: "3",
		});
		
		var TestServerForm = [];
		for (i=0;i<3;i++) {
		m = getRandomInt(0, 2);
			j = i + 1, k = j + 1, l = k + 1;
			TestServerForm[i] = JSON.stringify({
				question: JSON.parse(createFlashCard('test:'+i, i + ' x 1 = ??', i.toString())),
				answers: [JSON.parse(createFlashCard('test:'+i, i + ' x 1 = ??', i.toString())), 
				  JSON.parse(createFlashCard('test:'+j, i + ' x 1 = ??', j.toString())), 
				  JSON.parse(createFlashCard('test:'+k, i + ' x 1 = ??', k.toString())), 
				  JSON.parse(createFlashCard('test:'+l, i + ' x 1 = ??', l.toString()))],
				index: "" + (i + 1),
				time: "" + 5,
				player: null,
				enemy: JSON.parse(createFlashCard('test:'+m, m + ' x 1 = ??', m.toString())),
			});
		}
		
		// fetching info from server
		var INITIATING_FORM, SERVER_FORM;
		console.log("abc");
		// Start load test
			INITIATING_FORM = sessionStorage.getItem("initialization");
			console.log(INITIATING_FORM);
			//socket = CircularJSON.parse(sessionStorage.getItem("socket"));
			console.log(socket);
		// End load test

		var FLASH_SET = TestFlashSet;
		var DECK_SIZE = getDeckSize(FLASH_SET);
		var TOTAL_QUESTIONS = TestTotalQuestions;
		var PLAYER_SPRITE = "smiley.png";
		var ENEMY_SPRITE = "smiley.png";
		var BOMB_SPRITE = "bomb.png";
		var QUESTION_TIME = 10;
		var CURRENT_TIME = QUESTION_TIME;
		var TIMER;
		
		// interpreting info from server
		var initiatingJSON = JSON.parse(INITIATING_FORM);
		console.log(initiatingJSON);
		var playerName, playerSprite, playerPoints, playerWin, playerTotal;
		var enemyName, enemySprite, enemyPoints, enemyWin, enemyTotal;
		var encounterTotal, encounterWin, matchName, totalQuestions;
		
		var battleLibrary = []
		function createBattle(fcQ, fcA, playerA, enemyA, playerTime, enemyTime) {
			var battlePage = {
				question: fcQ,
				answers: fcA,
				player: playerA,
				enemy: enemyA,
				ptime: playerTime,
				etime: enemyTime,
			}
			return battlePage;
		}
		
		function convertPoints(timeMils, maxTime) { // all in milliseconds
			var resultPoints = ((maxTime - timeMils) / maxTime) * 10000;
			return Math.round(resultPoints);
		}
		
		var qppc = 15, appc = 10;
		var globalPlayerScore, globalEnemyScore;
		
//HERE********************************************************************************************
	window.addEventListener("load",function() {
	
	var Q = window.Q = Quintus()
    .include("Sprites, Scenes, Input, 2D, Anim, Touch, UI")
    .setup({
		maximize: true
	}).touch();
	
	// dynamic vars
	var qx = Q.width/320;
	var qy = Q.height/568;

	//Interpreting info from server
	var INITIATING_FORM, SERVER_FORM;
	INITIATING_FORM = sessionStorage.getItem("initialization");
	var initiatingJSON = JSON.parse(INITIATING_FORM);
	
	// load initiating form here
	playerName = initiatingJSON.playerName;
	playerSprite = initiatingJSON.playerSprite;
	playerPoints = initiatingJSON.playerPoints;
	playerWin = initiatingJSON.playerWin;
	playerTotal = initiatingJSON.playerTotal;
	enemyName = initiatingJSON.enemyName;
	enemySprite = initiatingJSON.enemySprite;
	enemyPoints = initiatingJSON.enemyPoints;
	enemyWin = initiatingJSON.enemyWin;
	enemyTotal = initiatingJSON.enemyTotal;
	encounterTotal = initiatingJSON.encounterTotal;
	encounterWin = initiatingJSON.encounterWin;
	matchName = initiatingJSON.matchName;
	totalQuestions = initiatingJSON.totalQuestions;	  
	  
	//PLAYER_NAME = "John Smith", ENEMY_NAME = "Darth Vader";
	
	// initialize Battle Library
	battleLibrary[0] = {
		totalQns: parseInt(totalQuestions),
		//enemyName: ENEMY_NAME,
	};
	
	Q.state.set({playerScore: 0, enemyScore: 0, currentIndex: 0, currentQuestion: "", waiting: true});
	//var deck = shuffleDeck(totalQuestions, DECK_SIZE);
	var isBombMoving = false;
	
	Q.UI.PlayerScore = Q.UI.Text.extend("UI.PlayerScore", { 
		init: function(p) {
			this._super(p, {
			  label: Q.state.get("playerScore") + "",
			  x: 20 * qx,
			  y: 30 * qy
			});
			Q.state.on("change.playerScore",this,"score");
		},
		
		score: function() {
			points = Math.floor(Q.state.get("playerScore") / 1000);
			this.p.label = points + "";
		}
	});
	
	Q.UI.EnemyScore = Q.UI.Text.extend("UI.EnemyScore", { 
		init: function(p) {
			this._super({
			  label: Q.state.get("enemyScore") + "",
			  x: 300 * qx,
			  y: 30 * qy
			});
			Q.state.on("change.enemyScore",this,"score");
		},
		
		score: function() {
			points = Math.floor(Q.state.get("enemyScore") / 1000);
			this.p.label = points + "";
		}
	});

	/*
	Q.UI.QuestionCounter = Q.UI.Text.extend("UI.QuestionCounter", { 
		init: function(p) {
			this._super({
			  label: "[Q: 1/" + TOTAL_QUESTIONS + "]",
			  x: 160,
			  y: 30
			});
			Q.state.on("change.currentIndex",this,"qc");
		},

		qc: function() {
			this.p.label = "[Q: " + Q.state.get("currentIndex") + "/" + TOTAL_QUESTIONS + "]";
		}
	});
	*/
	
	Q.UI.TimeCounter = Q.UI.Text.extend("UI.TimeCounter", { 
		init: function(p) {
			this._super({
			  label: "n/a",
			  x: 160 * qx,
			  y: 30 * qy,
			});
		},
	});
	
	Q.PlayerPortrait = Q.Sprite.extend("PlayerPortrait", {
		init: function(p) {
			this._super(p, {
				x: 30 * qx,
				y: 530 * qy,
				scale: 0.03,
				//asset: PLAYER_SPRITE
			});
		},
	});
	
	Q.EnemyPortrait = Q.Sprite.extend("EnemyPortrait", {
		init: function(p) {
			this._super(p, {
				x: 290 * qx,
				y: 530 * qy,
				scale: 0.03,
				asset: enemySprite
			});
		},
	});
	
	Q.Bomb = Q.Sprite.extend("Bomb", {
		init: function(p) {
			this._super(p, {
				x: 160 * qx,
				y: 530 * qy,
				scale: 0.03,
				distance: 0,
				asset: BOMB_SPRITE
			});
		},
		
		step: function(dt) {
			if (isBombMoving) {
				this.p.vx = distance/60;
				this.p.x += this.p.vx;
			}
		
			//this.p.vx += dt * 100;
			//this.p.x += this.p.vx * dt;
		}
	});

    
	// Flash Card
	Q.UI.FlashCard = Q.UI.Text.extend('UI.FlashCard', {
		// default position is question
		init: function(p) {
			this._super(p, {
				color: "black",
				x: 	0,
				y: 	0,
				id: 'fc-null',
				question: 'q-null',
				answer: 'a-null',
				isQuestion: true
			});
		},
	
	// load flashcard properties
		generate: function(param) {
			parsedArgument = param;			
			this.p.id = parsedArgument.id;
			this.p.question = parsedArgument.question;
			this.p.answer = parsedArgument.answer;
			if (this.p.isQuestion) {
				this.p.label = wordWrap(this.p.question, 250, qppc);
			} else {
				this.p.label = this.p.answer;
			}
		},
	});
	
	//answer button
		Q.UI.AnswButton = Q.UI.Button.extend('UI.AnswButton', {
		init: function(p) {
			this._super(Q._defaults(p, {
				fill: "#FFFFFF",
				//highlight: "#FFFFFF",
				fontColor: "white",
				border: 2,
				shadow: 3,
				shadowColor: "rgba(0,0,0,0.5)",
				w: 40 * qx,
				h: 40 * qy
			}),                     
			function() {
					
			});
		},
		});
		
	// versus screen with countdown
	Q.scene("scene0", function(stage) {
	
		var playerContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: ((2/3) * 320) * qx,
			y: 90 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: (((2/3) * 320) - 20) * qx,
			h: 150 * qy
		}));
		
		var enemyContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: ((2/3) * 320) * qx,
			y: 478 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: (((2/3) * 320) - 20) * qx,
			h: 150 * qy
		}));
		
		function expressStats(iName, iLevel, iTitle, iWinRate, iTotalMatches) {
			var labelStr = "[" + iName + "]" + "\n" +
			  "Level " + iLevel + " " + iTitle + "\n" +
			  "Winrate: " + iWinRate + "%" + "\n" +
			  "Total Matches: " + iTotalMatches;
			return labelStr;
		}
		
		function getWinRate(wins, total) {
			return ((wins/total)*100).toFixed(1);
		}
		
		function getLevel(accumPoints) {
			return Math.floor(accumPoints/100000);
		}
		
		var playerStats = stage.insert(new Q.UI.Text({size: 32}), playerContainer);
		var enemyStats = stage.insert(new Q.UI.Text({size: 32}), enemyContainer);
		playerStats.p.label = expressStats(playerName, getLevel(playerPoints), 'Player', getWinRate(playerWin, playerTotal), playerTotal);
		enemyStats.p.label = expressStats(enemyName, getLevel(enemyPoints), 'Opponent', getWinRate(enemyWin, enemyTotal), enemyTotal);
		
		var playerPortrait = stage.insert(new Q.PlayerPortrait({
			x: qx * 65, 
			y: qy * 90, 
			scale: 1, 
			asset: playerSprite,
		}));
		
		var enemyPortrait = stage.insert(new Q.EnemyPortrait({
			x: qx * 65, 
			y: qy * 478, 
			scale: 1, 
			asset: enemySprite,
		}));
		
		var matchContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: ((2/3) * 320) * qx,
			y: 284 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: (((2/3) * 320) - 20) * qx,
			h: 200 * qy
		}));
		
		function expressMatch(matchName, totalQuestions, encounterTotal, encounterWin) {
			var outStr;
			outStr = "<< Match Details >>" + "\n\n" +
			  "[" + matchName + "]" + "\n" +
			  totalQuestions + " Questions" + "\n\n";
			if (encounterTotal == 0) {
				outStr += "First Encounter!";
			} else {
				var ewr = ((encounterWin/encounterTotal) * 100).toFixed(2);
				if (ewr > 75) {
					outStr += "Deliver the Smackdown!";
				} else if (ewr < 25) {
					outStr += "Reclaim your Honor!";
				} else {
					outStr += "Struggle for Dominance!";
				}
				outStr += "\n";
				var numDenom;
				switch (encounterTotal) {
					case 1:
						numDenom = "nd";
						break;
					case 2:
						numDenom = "rd";
						break;
					default:
						numDenom = "th";
				}
				outStr += (encounterTotal + 1) + numDenom + " Encounter" + "\n" +
				  ewr + "% success rate";
			}
			return outStr;
		}
		
		var loadContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: 65 * qx,
			y: 284 * qy,
			w: 80 * qx,
			h: 202 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
		}));
		
		var loadBox = [], numBox = 21, midNum = Math.floor(numBox/2), incLvl = Math.floor((numBox - 1) / 2);
		for (i=0;i<numBox;i++) {
			loadBox[i] = stage.insert(new Q.UI.Container({
				fill: "white",
				x: 65 * qx,
				y: (184 + (100/numBox) + (i * (200/numBox))) * qy,
				w: 78 * qx,
				h: (200/numBox) * qy,
			}));
		}
		loadBox[midNum].p.fill = "green";
		
		var timerBox = stage.insert(new Q.UI.Container({
			fill: "white",
			x: (65) * qx,
			y: (284) * qy,
			w: 40 * qx,
			h: 40 * qy,
			border: 1,
		}));
		
		var timerCD = stage.insert(new Q.UI.Text({size: 50, label: ""}), timerBox);
		
		var matchDetails = stage.insert(new Q.UI.Text({size: 28}), matchContainer);
		matchDetails.p.label = expressMatch(matchName, totalQuestions, encounterTotal, encounterWin);
		
		var cdSec = 10;
		var cdTimer = new Countdown({
			seconds: cdSec,
			onUpdateStatus: function(sec) {
				var ceilSec = Math.ceil(sec);
				var incCS = cdSec - ceilSec;
				loadBox[midNum + incCS].p.fill = "green";
				loadBox[midNum - incCS].p.fill = "green";
				timerCD.p.label = ceilSec + "";
			},
			onCounterEnd: function() {
				setTimeout(function() {Q.stageScene("scene1");}, 1000);
			}
		});
		
		cdTimer.start();
	});
	
	// set scene
	Q.scene("scene1",function(stage) {
	
		Q.state.reset({playerScore: 0, enemyScore: 0, currentIndex: 0, currentQuestion: "", waiting: true, isGameOver: false});
	
		var playerScore = stage.insert(new Q.UI.PlayerScore());
		var enemyScore = stage.insert(new Q.UI.EnemyScore());
		//var leQC = stage.insert(new Q.UI.QuestionCounter());
		var leTC = stage.insert(new Q.UI.TimeCounter());
		var ansDeck;
		var isPhaseOne = true;
		var timeTakenCurrent = 0;
		
		// start receive serverForm
		var serverJSON, fcQuestion, fcAnswers, questionNumber = "0", maxTimeAllowed, prevPlayerAns, prevEnemyAns, prevPlayerTime, prevEnemyTime;
		var timeOutTimer, gameOverTimer;
		var currentFcAnswer, prevFcQuestion;
		//Q.state.set("currentQuestion", fcQuestion.id);
		// end receive serverForm
		
		timeOutTimer = setTimeout(function(){
			if (serverJSON == null) {
				alert("TIMEOUT");
    			window.location.href = "study.html";
			}
		}, 10000);
		
		function generateAnswers() {
			Q.state.set("waiting", false);
			var aBtns = [];
			var k = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					var fcAns = fcAnswers[k].answer;
					var ansColor = "red";
					if (fcQuestion.id == fcAnswers[k].id) {
						ansColor = "green";
					}
					aBtns[k] = stage.insert(new Q.UI.Button({
						fill: "white",
						highlight: ansColor,
						fontColor: "black",
						x: (90 + (140*j)) * qx,
						y: (320 + (120*i)) * qy,
						border: 2,
						shadow: 3,
						shadowColor: "rgba(0,0,0,0.5)",
						w: 110 * qx,
						h: 100 * qy,
						label: fcAns,
						counter: k,
						customId: fcAnswers[k].id,
						}, function() {
							// do something
							if (!Q.state.get("waiting")) {
								timeTakenCurrent = TIMER.getTime();
								Q.state.set("waiting", true);
							
								var k = this.p.counter;
								if (fcQuestion.id == fcAnswers[k].id) {
									console.log("Placeholder Trigger: Correct");
									playerCounters[Q.state.get("currentIndex") - 1].p.fill = "green";
									this.p.fill = "green";
									Q.state.inc("playerScore", convertPoints(timeTakenCurrent, maxTimeAllowed * 1000));
								} else {
									console.log("Placeholder Trigger: Wrong");
									playerCounters[Q.state.get("currentIndex") - 1].p.fill = "red";
									this.p.fill = "red";
								}
								
								currentFcAnswer = this.p.customId;
								//Q.state.inc("currentIndex", 1);
								
								
								
								// send form to server and wait for next
								clientJSON = createClientToServerJSON(fcQuestion.id, currentFcAnswer, timeTakenCurrent, Q.state.get("currentIndex") + "");
								console.log("Post to Server: " + clientJSON);
								socket.emit("readanswer", clientJSON);
								
							}
					}));
					
					k++;
				}
			}
			
			return aBtns;
		}
		
		function outOfTime() {
			if (!Q.state.get("waiting")) {
			Q.state.set("waiting", true);
			timeTakenCurrent = maxTimeAllowed * 1000;
			currentFcAnswer = "null";
			clientJSON = createClientToServerJSON(fcQuestion.id, currentFcAnswer, timeTakenCurrent, Q.state.get("currentIndex") + "");
			console.log("Post to Server: " + clientJSON);
			socket.emit("readanswer", clientJSON);
			}
		}
		
		function destroyAnswers(aBtns) {
			for (i=0;i<aBtns.length;i++) {
				aBtns[i].destroy();
			}
		}
		
		// player/enemy's counters
		// x = 15/305; y = 280; w = 15; h = 420; border: 2
		// boundary for y: from 70 to 490; origin is centre
		
		for (i=0;i<totalQuestions;i++) {
			playerCounters[i] = stage.insert(new Q.UI.Container({
				fill: "white",
				x: 15 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/totalQuestions) - (i*(420/totalQuestions))) * qy,
				h: (420/totalQuestions) * qy
			}));
			
			enemyCounters[i] = stage.insert(new Q.UI.Container({
				fill: "white",
				x: 305 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/totalQuestions) - (i*(420/totalQuestions))) * qy,
				h: (420/totalQuestions) * qy
			}));
		}

	
		//current question
		var qContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: 160 * qx,
			y: 160 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 250 * qx,
			h: 180 * qy
		}));
		
		if (Q.state.get("currentIndex") > 0) {
		var aBtns = generateAnswers();
		var qCard = stage.insert(new Q.UI.FlashCard(),qContainer);
		qCard.generate(fcQuestion);
		}
		var qCard;
		//var qCard = stage.insert(new Q.UI.FlashCard(),qContainer);
		
		var playerPortrait = stage.insert(new Q.PlayerPortrait());
		var enemyPortrait = stage.insert(new Q.EnemyPortrait());
		//var player1 = stage.insert(new Q.PlayerPiece());
		//var player2 = stage.insert(new Q.EnemyPiece());
		var bomb = stage.insert(new Q.Bomb());
		
		var raceLine = stage.insert(new Q.UI.Container({
			fill: "black",
			// from 60 to 260
			x: 160 * qx,
			y: 550 * qy,
			w: 200 * qx,
			h: 3 * qy
		}));
		
	// include an event handler, when receive from server, set variables, then set "received" to true.
	var prevMaxTime = 0, maxTimeAllowed = 0;
	
		socket.on('nextQuestion', function(msg) {
            //$('#log').append('<br>Received #' + msg.count + ': ' + msg.data);
			//Q.state.set("received", true);
			var sqn = fcQuestion,
			  sans = fcAnswers,
			  sqnN = questionNumber;
			prevMaxTime = maxTimeAllowed;
			
			if (Q.state.get("currentIndex") > 0) {prevFcQuestion = fcQuestion};
			serverJSON = JSON.parse(msg.data);
			fcQuestion = serverJSON.question,
			  fcAnswers = serverJSON.answers,
			  questionNumber = parseInt(serverJSON.index),
			  prevPlayerAns = serverJSON.player,
			  prevEnemyAns = serverJSON.enemy,
			  prevPlayerTime = serverJSON.playerTime,
			  prevEnemyTime = serverJSON.enemyTime;
			maxTimeAllowed = serverJSON.time;
			clearTimeout(timeOutTimer);
	
			battleLibrary[sqnN] = createBattle(sqn, sans, prevPlayerAns, prevEnemyAns, prevPlayerTime, prevEnemyTime);
			
			if (isNaN(questionNumber)) {questionNumber = -1;}
			Q.state.inc("currentIndex", 1);
			console.log("yatish socket received: " + msg.data);
        });
		
		socket.on('gameOver', function(msg) {
			console.log(msg.data);
			Q.state.set("isGameOver", true);
			socket.emit('disconnect');
		});
		
		Q.state.on("change.isGameOver", function() {
			if (Q.state.get("isGameOver")) {
				clearInterval(gameOverTimer);
				globalPlayerScore = Q.state.get("playerScore");
				globalEnemyScore = Q.state.get("enemyScore");
				setTimeout(function() {Q.stageScene("scene2");}, 1000);
			}
			
			//alert("Game Over");
		});
			
	
		Q.state.on("change.currentIndex", function() {
			
			console.log(serverJSON);
		
			if (Q.state.get("currentIndex") >= questionNumber) {				  


			// express enemy previous answer
			if (Q.state.get("currentIndex") > 1) {
			console.log("TIME OF RECKONING: " + (prevFcQuestion.id == prevEnemyAns));
			console.log("prevQnId " + prevFcQuestion.id + " vs enemy " + prevEnemyAns)
			console.log(prevEnemyTime + " " + prevMaxTime + " " + convertPoints(prevEnemyTime, prevMaxTime * 1000));
				if (prevFcQuestion.id == prevEnemyAns) {
					enemyCounters[Q.state.get("currentIndex") - 2].p.fill = "green";
					Q.state.inc("enemyScore", convertPoints(prevEnemyTime, prevMaxTime * 1000));
				} else {
					enemyCounters[Q.state.get("currentIndex") - 2].p.fill = "red";
				}
				if (prevPlayerAns == "null") {
					playerCounters[Q.state.get("currentIndex") - 2].p.fill = "red";
				}
			}
			
				
			// result in bomb movement
				var remainingQ = (totalQuestions - Q.state.get("currentIndex") + 1) * 1000;
				var scoreDiff = Q.state.get("playerScore") - Q.state.get("enemyScore");
				if (remainingQ > 0) {
					if (scoreDiff <= remainingQ) {
						bomb.p.x = (160 + ((scoreDiff/remainingQ)*100)) * qx;
					} else if (scoreDiff > remainingQ) {
						if (isPhaseOne) {
							// initiate Phase 2
							bomb.destroy();
							console.log("PHASE TWO");
							isPhaseOne = false;
						}
					}
				} else {
					// no more qns = game essentially end
				}
			
				// start next question
				if (Q.state.get("currentIndex") == 1) {
					qCard = stage.insert(new Q.UI.FlashCard(),qContainer);
				}

				if(totalQuestions - Q.state.get("currentIndex") >= 0) {
					// Get next question only if there is another question to show

					qCard.generate(fcQuestion);
					if (Q.state.get("currentIndex") > 1) {destroyAnswers(aBtns)};
					aBtns = generateAnswers();
					if (Q.state.get("currentIndex") > 1) {TIMER.stop();}
					if (Q.state.get("currentIndex") > 0 && Q.state.get("currentIndex") <= totalQuestions) {
						TIMER = new Countdown({
							seconds: maxTimeAllowed,
							onUpdateStatus: function(sec) {leTC.p.label = sec + "";},
							onCounterEnd: function() {outOfTime();}
						});
						TIMER.start();
					}
				}

								
			}
			
		});

	});
	
	// set scene
	Q.scene("scene2",function(stage) {
	
		var ResultsBanner = stage.insert(new Q.UI.Button({
			fill: "white",
			fontColor: "black",
			border: 2,
			shadow: 3,
			x: (320/2) * qx,
			y: 48 * qy,
			w: 290 * qx,
			h: 60 * qy,
		}));
		
		if (globalPlayerScore > globalEnemyScore) {
			ResultsBanner.p.label = "Glorious Victory :)";
		} else if (globalPlayerScore < globalEnemyScore) {
			ResultsBanner.p.label = "You Lose :(";
		} else {
			ResultsBanner.p.label = "Draw :O";
		}
		
		var ResultsBox = stage.insert(new Q.UI.Container({
			fill: "white",
			fontColor: "black",
			border: 2,
			shadow: 3,
			x: (320/2) * qx,
			y: (((450-78)/2)+78) * qy,
			w: 290 * qx,
			h: 350 * qy,
		}));
	
		var ReviewBtn = stage.insert(new Q.UI.Button({
			fill: "white",
			fontColor: "black",
			highlight: "gray",
			x: (320/4) * qx,
			y: 500 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 130 * qx,
			h: 100 * qy,
			label: 'Review',
		}, function() {
			Q.stageScene("scene3");
		}));
		
		var BackBtn = stage.insert(new Q.UI.Button({
			fill: "white",
			fontColor: "black",
			highlight: "gray",
			x: (3/4) * 320 * qx,
			y: 500 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 130 * qx,
			h: 100 * qy,
			label: 'Back',
		}, function() {
			// return to interface
			window.location.href="study.html";
		}));
		
		
	});
	
	Q.scene("scene3", function(stage) {
	
		// scene-local variables
		var passive_opacity = 0.3;
	

		function generateAnswers() {
			var aBtns = [];
			var k = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					var fcAns = fcAnswers[k].answer;
					var fillColor = "white", wordColor = "black";
					if (fcQuestion.id == fcAnswers[k].id) {
						fillColor = "green";
						wordColor = "white";
					} else {
						if (fcAnswers[k].id == pAnswer || fcAnswers[k].id == eAnswer) {
							fillColor = "red";
							wordColor = "white";
						}
					}
					
					aBtns[k] = stage.insert(new Q.UI.Button({
						fill: fillColor,
						//highlight: ansColor,
						fontColor: wordColor,
						x: (90 + (140*j)) * qx,
						y: (320 + (120*i)) * qy,
						border: 2,
						shadow: 3,
						shadowColor: "rgba(0,0,0,0.5)",
						w: 110 * qx,
						h: 100 * qy,
						label: fcAns,
						counter: k,
						customId: fcAnswers[k].id,
						}, function() {
							// do something
					}));
					
					k++;
				}
			}
			
			return aBtns;
		}
		
		function generateTabs() {
			var aTabs = [];
			var k = 0, ka = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					for (l=0;l<2;l++) {
						var fcAns = fcAnswers[ka];
						var fillColor = "white";
						if ((l == 0 && fcAns.id == pAnswer) || 
						  (l == 1 && fcAns.id == eAnswer)) {
							fillColor = "gray";
							
							
						
						aTabs[aTabs.length] = stage.insert(new Q.UI.Container({
							fill: fillColor,							
							x: (62.5 + (140*j) + (55*l)) * qx,
							y: (265 + (120*i)) * qy,
							border: 2,
							shadow: 3,
							shadowColor: "rgba(0,0,0,0.5)",
							w: 55 * qx,
							h: 10 * qy,
						}));
						
						k++;
						}
					}
					ka++;
				}
			}
			
			return aTabs;
		}
		
		function destroyAnswers(aBtns, aTabs) {
			for (i=0;i<aBtns.length;i++) {
				aBtns[i].destroy();
			}
			for (j=0;j<aTabs.length;j++) {
				aTabs[j].destroy();
			}
		}
	
		// battleLibrary[0] = totalQns, enemyName
		// battleLibrary[i] = question, answers, player, enemy, ptime, etime
	
		Q.state.reset({battleIndex: 0, totalIndex: 0});
		//Q.state.set("totalIndex", battleLibrary[0].totalQns);
		Q.state.set("totalIndex", parseInt(totalQuestions));
		
		var fcQuestion, fcAnswers, pAnswer, eAnswer, pTime, eTime, aBtns, aTabs;
	
		Q.state.on("change.battleIndex", function() {
			battlePage = battleLibrary[Q.state.get("battleIndex")];
			fcQuestion = battlePage.question;
			fcAnswers = battlePage.answers;
			pAnswer = battlePage.player; // id
			eAnswer = battlePage.enemy; // id
			pTime = battlePage.ptime;
			eTime = battlePage.etime;
			
			if (aBtns != null && aTabs != null) {destroyAnswers(aBtns, aTabs);}
			if (qCard != null) {qCard.destroy();}
			if (PrevQBtn != null) {PrevQBtn.destroy();}
			if (NextQBtn != null) {NextQBtn.destroy();}
			
			qCard = stage.insert(new Q.UI.FlashCard(), qContainer);
			qCard.generate(fcQuestion);
			aBtns = generateAnswers();
			aTabs = generateTabs();

			if (pAnswer == "null") {
				PTimeCounter.p.label = "None";
			} else {
				PTimeCounter.p.label = (pTime / 1000).toFixed(3) + " s";
			}
			if (eAnswer == "null") {
				ETimeCounter.p.label = "None";
			} else {
				ETimeCounter.p.label = (eTime / 1000).toFixed(3) + " s";
			}
			
			
			
			QCounter.p.label = Q.state.get("battleIndex") + " / " + Q.state.get("totalIndex");
			if (pBattleCounters.length > 0) {
				for (i=0;i<pBattleCounters.length;i++) {
					pBattleCounters[i].p.opacity = passive_opacity;
				}
				pBattleCounters[Q.state.get("battleIndex") - 1].p.opacity = 1;
			}
			if (eBattleCounters.length > 0) {
				for (i=0;i<eBattleCounters.length;i++) {
					eBattleCounters[i].p.opacity = passive_opacity;
				}
				eBattleCounters[Q.state.get("battleIndex") - 1].p.opacity = 1;
			}
			
			if (Q.state.get("battleIndex") > 1) {
				PrevQBtn = stage.insert(new Q.UI.Button({
				  fill: "white",
				  fontColor: "black",
				  highlight: "gray",
				  x: ((320/4) - 30) * qx,
				  y: 535 * qy,
				  border: 2,
				  shadow: 3,
				  shadowColor: "rgba(0,0,0,0.5)",
				  w: 70 * qx,
				  h: 40 * qy,
				  label: "< P",
				}, function() {
					Q.state.inc("battleIndex", -1);
				}));
			}
			if (Q.state.get("battleIndex") < Q.state.get("totalIndex")) {
				NextQBtn = stage.insert(new Q.UI.Button({
				  fill: "white",
				  fontColor: "black",
				  highlight: "gray",
				  x: ((0.75*320) + 30) * qx,
				  y: 535 * qy,
				  border: 2,
				  shadow: 3,
				  shadowColor: "rgba(0,0,0,0.5)",
				  w: 70 * qx,
				  h: 40 * qy,
				  label: 'N >',
				}, function() {
					Q.state.inc("battleIndex", 1);
				}));
			}
		});
	
		var qContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: 160 * qx,
			y: 160 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 250 * qx,
			h: 180 * qy
		}));
		
		var PrevQBtn, NextQBtn, qCard;
		
		var QCounter = stage.insert(new Q.UI.Button({
			fill: "white",
			x: 160 * qx,
			y: 535 * qy,
			w: 120 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: ""
		}));
		
		var PTimeCounter = stage.insert(new Q.UI.Button({
			fill: "white",
			x: ((320/4) - 25) * qx,
			y: 35 * qy,
			w: 95 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: ""
		}));
		
		var ETimeCounter = stage.insert(new Q.UI.Button({
			fill: "white",
			x: ((0.75*320) + 25) * qx,
			y: 35 * qy,
			w: 95 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: ""
		}));
		
		var ReturnBtn = stage.insert(new Q.UI.Button({
			fill: "white",
			highlight: "gray",
			x: (320/2) * qx,
			y: 35 * qy,
			w: 80 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: "Back"
		}, function() {
			Q.stageScene("scene2");
		}));
		
		var pBattleCounters = [], eBattleCounters = [];
		Q.state.inc("battleIndex", 1);
		
		for (i=0;i<Q.state.get("totalIndex");i++) {
			var battlePage = battleLibrary[i+1];
			var playerFill = "red", enemyFill = "red";
			var playerOp = passive_opacity, enemyOp = passive_opacity;
			if (battlePage.question.id == battlePage.player) {
				playerFill = "green";
			}
			if (battlePage.question.id == battlePage.enemy) {
				enemyFill = "green";
			}
			if (i == 0) {
				playerOp = 1, enemyOp = 1;
			}
			pBattleCounters[i] = stage.insert(new Q.UI.Container({
				fill: playerFill,
				opacity: playerOp,
				x: 15 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/Q.state.get("totalIndex")) - (i*(420/Q.state.get("totalIndex")))) * qy,
				h: (420/Q.state.get("totalIndex")) * qy
			}));
			
			eBattleCounters[i] = stage.insert(new Q.UI.Container({
				fill: enemyFill,
				opacity: enemyOp,
				x: 305 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/Q.state.get("totalIndex")) - (i*(420/Q.state.get("totalIndex")))) * qy,
				h: (420/Q.state.get("totalIndex")) * qy
			}));
		}

		
	});
	
	// stage scene
	Q.load([PLAYER_SPRITE, ENEMY_SPRITE, BOMB_SPRITE, playerSprite, enemySprite], function() {
		Q.stageScene("scene0");
	});
     
});
	</script>
 </body>
 
 <footer>
	<script>
		INITIATING_FORM = sessionStorage.getItem("initialization");
		initiatingJSON = JSON.parse(INITIATING_FORM);
		gameroom = initiatingJSON.room;
		console.log(gameroom);
		socket.emit('gameinitialised', {"room":gameroom});
	</script>
	<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46324526-3', 'auto');
      ga('send', 'pageview');
	  </script>
 </footer>
</html>