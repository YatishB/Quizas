<!DOCTYPE html>
<html>
 <head>
	<meta name="viewport" content="width=device-width, user-scalable=no" />
	<title></title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src='http://cdn.html5quintus.com/v0.2.0/quintus-all.js'></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
	<script src="js/quizas_gamestats_linegraph.js"></script>
	<link rel="stylesheet" type="text/css" href="css/quizas_gamestats_linegraph.css"></link>
	<!-- <script src='http://cdnjs.cloudflare.com/ajax/libs/socket.io/0.9.16/socket.io.min.js'></script> -->
    <!-- <script src='example1.js'></script> -->
	<link rel="stylesheet" type="text/css" href="css/multiPlayer.css">
	<script>
		var globalTestVar, gtv_a, gtv_b, gtv_c;
		var NUKE_SOUND = "Bomb_Explosion.mp3";
		var NUKE_SPRITE = "mushroom_cloud.jpg";
	
	
		// socket stuff
	/*
			namespace = '/test'; // change to an empty string to use the global namespace

            // the socket.io documentation recommends sending an explicit package upon connection
            // this is specially important when using the global namespace
            var socket = io.connect('http://' + document.domain + ':' + location.port + namespace,
                                    {"connect timeout": 300,
                                     "close timeout": 30,
                                     "hearbeat timeout": 30});
            socket.on('connect', function() {
            });
			
			 
		
		// socket handler
		socket.on('initiating', function(msg) {
                //$('#log').append('<br>Received #' + msg.count + ': ' + msg.data);
            });
	*/
		
	
		// helper functions
				
		function insertString(a, position, b) {
			return output = a.substr(0, position) + b + a.substr(position);
		}
		
		function wordWrap(iStr, cardWidth, pixelPerChar) {
			var wrappedStr = iStr;
			var n = iStr.length;
			
			if ((n * pixelPerChar) > cardWidth) {
				var m = Math.floor((n * pixelPerChar)/cardWidth);
				for (i=0;i<m;i++) {
					//wrappedStr = insertString(wrappedStr, (i+1)*(cardWidth/pixelPerChar), "\n");
					position = Math.floor((i+1)*(cardWidth/pixelPerChar));
					wrappedStr = wrappedStr.substr(0, position) + "\n" + wrappedStr.substr(position);
				}
			}
			return wrappedStr;
		}
		
		function Countdown(options) {
			var timer,
			  instance = this,
			  seconds = options.seconds || 10,
			  updateStatus = options.onUpdateStatus || function () {},
			  counterEnd = options.onCounterEnd || function () {},
			  offset, max;
			  
			function decrementCounter() {
				d = delta();
				seconds = (seconds >= d) ? seconds -= d : 0;
				updateStatus((seconds/1000).toFixed(2));
				if (seconds <= 0) {
					counterEnd();
					instance.stop();
				}
			}
			
			function delta() {
				var now = Date.now(),
				  d = now - offset;
				offset = now;
				return d;
			}
			
			this.getTime = function() {
				return (max - seconds);
			};

			this.start = function () {
				clearInterval(timer);
				timer = 0;
				offset = Date.now();
				max = options.seconds * 1000;
				seconds = options.seconds * 1000;
				timer = setInterval(decrementCounter, 10);
			};

			 this.stop = function () {
				clearInterval(timer);
			};
		}
	
		function parseBool(param) {
			return (param === 'true');
		}
		
		function createFlashCard(pId, pQn, pAns) {
			var fc = JSON.stringify({
				id: pId, 
				question: pQn, 
				answer: pAns, 
			});
			return fc;
		}
		
		function createFlashSet(pId, pN, pC, pFc) {
			var fs = JSON.stringify({
				id: pId,
				name: pN,
				category: pC,
				cards: pFc
			});
			return fs;
		}
		
		function getFlashCard(flashSet, n) { // input fs and output fc all in JSON
			var fs = JSON.parse(flashSet);
			var fc = fs.cards[n];
			return fc;
		}
		
		function getDeckSize(flashSet) { // input in JSON, output in integer
			var parsedDeck = JSON.parse(flashSet);
			var n = parsedDeck.cards.length;
			return n;
		}
		
		function shuffle(array) { // http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
			var currentIndex = array.length, temporaryValue, randomIndex ;

			// While there remain elements to shuffle...
			while (0 !== currentIndex) {

				// Pick a remaining element...
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex -= 1;

				// And swap it with the current element.
				temporaryValue = array[currentIndex];
				array[currentIndex] = array[randomIndex];
				array[randomIndex] = temporaryValue;
			}

		return array;
		}
		
		/**
		 * Returns a random integer between min (inclusive) and max (inclusive)
		 * Using Math.round() will give you a non-uniform distribution!
		 */
		function getRandomInt(min, max) {
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}
		
		function shuffleDeck(x, n) { // x = decksize, n = totalsize
			var deck = [];
			for (i=0;i<n;i++) {
				deck[i] = i;
			}
			var newDeck = shuffle(deck);
			var chosenDeck = newDeck.slice(0, x);
			return chosenDeck;
		}
		
		function dealAnswers(a, n) { // a = order # of answer, n = decksize
			var deck = [];
			var iniCounter = 0;
			for (i=0;i<n;i++) {
				if (i != a) {
					deck[iniCounter] = i;
					iniCounter = iniCounter + 1;
				}
			}
			var newDeck = shuffle(deck);
			var chosenDeck = newDeck.slice(0, 3);
			var finalDeck = [];
			var hasInserted = false;
			var deckCounter = 0;
			for (i=0;i<4;i++) {
				var decision = Math.random() < 0.5;
				if (!hasInserted && (decision || i == 3)) {
					finalDeck[i] = a;
					hasInserted = true;
				} else {
					finalDeck[i] = chosenDeck[deckCounter];
					deckCounter = deckCounter + 1;
				}
			}
			return finalDeck;
		}
		
		function createClientToServerJSON(questionId, answerId, timeTaken, questionsCompleted) {
			var clientJSON = JSON.stringify({
				id: questionId,
				answer: answerId,
				time: timeTaken,
				done: questionsCompleted,
			});
			return clientJSON;
		}
		
		// some global variables
		var playerCounters = [];
		var enemyCounters = [];

		// declare JSON vars for testing purposes
		var TestFlashCard = createFlashCard('22', 'F=??', 'M x A');
		
		var TestFCArray = [];
		for (i=0;i<30;i++) {
			var stringId = i.toString();
			var stringQn = i.toString() + ' + ' + i.toString() + ' = ??';
			var stringAns = (i + i).toString();
			var fc = createFlashCard(stringId, stringQn, stringAns);
			TestFCArray[i] = fc;
		}
		var TestFlashSet = createFlashSet('101', 'Simple Additions', 'Mathematics', TestFCArray);
		var TestTotalQuestions = 10;
		
		var TestInitiatingForm = JSON.stringify({
			playerName: "John Smith",
			playerSprite: "http://www.gamedevacademy.org/wp-content/uploads/2014/10/crashthedrone1-170x80.png",
			playerPoints: 300*50000,
			playerWin: 120,
			playerTotal: 300,
			enemyName: "Darth Vader",
			enemySprite: "https://fbcdn-profile-a.akamaihd.net/hprofile-ak-xfa1/v/t1.0-1/p100x100/10624735_10154690559390417_2870427952069110535_n.jpg?oh=07d4469d6b72d8f2f1054c08e94d32dc&oe=550F335E&__gda__=1428092526_48a8093944904d6de6299272d83ced04",
			enemyPoints: 750*64000,
			enemyWin: 800,
			enemyTotal: 1000,
			encounterTotal: 12,
			encounterWin: 3,
			matchName: "Hardkore Mathematics",
			totalQuestions: 10,
			room: "something",
		});
		
		var TestServerForm = [];
		for (i=0;i<3;i++) {
		m = getRandomInt(0, 2);
			j = i + 1, k = j + 1, l = k + 1;
			TestServerForm[i] = JSON.stringify({
				question: JSON.parse(createFlashCard('test:'+i, i + ' x 1 = ??', i.toString())),
				answers: [JSON.parse(createFlashCard('test:'+i, i + ' x 1 = ??', i.toString())), 
				  JSON.parse(createFlashCard('test:'+j, i + ' x 1 = ??', j.toString())), 
				  JSON.parse(createFlashCard('test:'+k, i + ' x 1 = ??', k.toString())), 
				  JSON.parse(createFlashCard('test:'+l, i + ' x 1 = ??', l.toString()))],
				index: "" + (i + 1),
				time: "" + 5,
				player: null,
				enemy: JSON.parse(createFlashCard('test:'+m, m + ' x 1 = ??', m.toString())),
			});
		}
		
		// fetching info from server
		var INITIATING_FORM, SERVER_FORM;
		
		// Start load test
			INITIATING_FORM = TestInitiatingForm;
			
		// End load test

		var FLASH_SET = TestFlashSet;
		var DECK_SIZE = getDeckSize(FLASH_SET);
		var TOTAL_QUESTIONS = TestTotalQuestions;
		var PLAYER_SPRITE = "smiley.png";
		var ENEMY_SPRITE = "smiley.png";
		var BOMB_SPRITE = "bomb.png";
		var QUESTION_TIME = 10;
		var CURRENT_TIME = QUESTION_TIME;
		var TIMER;
		
		// interpreting info from server
		var initiatingJSON = JSON.parse(INITIATING_FORM);
		console.log(initiatingJSON);
		var playerName, playerSprite, playerPoints, playerWin, playerTotal;
		var enemyName, enemySprite, enemyPoints, enemyWin, enemyTotal;
		var encounterTotal, encounterWin, matchName, totalQuestions;
		
		var battleLibrary = []
		function createBattle(fcQ, fcA, playerA, enemyA, playerTime, enemyTime) {
			var battlePage = {
				question: fcQ,
				answers: fcA,
				player: playerA,
				enemy: enemyA,
				ptime: playerTime,
				etime: enemyTime,
			}
			return battlePage;
		}
		
	</script>
 </head>
 
 <body>
	<script>
	window.addEventListener("load",function() {
		//setTimeout(function() {
		//	socket.emit('assignroom', {flashset: "quizlet:39748410", user1: "quizlet:yatish", user2: "quizlet:byatishyuvaraj"});
		//}, 10000);
	var Q = window.Q = Quintus({audioSupported: ['mp3', 'wav']})
    .include("Sprites, Scenes, Input, 2D, Anim, Touch, UI, Audio")
    .setup({
		//width: 300,
		//height: 675,
		//scaleToFit: true
		maximize: true
	}).touch().enableSound();
	
	// dynamic vars
	var qx = Q.width/320;
	var qy = Q.height/568;
	
	// load initiating form here
	playerName = initiatingJSON.playerName;
	playerSprite = initiatingJSON.playerSprite;
	playerPoints = initiatingJSON.playerPoints;
	playerWin = initiatingJSON.playerWin;
	playerTotal = initiatingJSON.playerTotal;
	enemyName = initiatingJSON.enemyName;
	enemySprite = initiatingJSON.enemySprite;
	enemyPoints = initiatingJSON.enemyPoints;
	enemyWin = initiatingJSON.enemyWin;
	enemyTotal = initiatingJSON.enemyTotal;
	encounterTotal = initiatingJSON.encounterTotal;
	encounterWin = initiatingJSON.encounterWin;
	matchName = initiatingJSON.matchName;
	totalQuestions = initiatingJSON.totalQuestions;	  
	  
	 battleLibrary[0] = totalQuestions;

	PLAYER_NAME = "John Smith", ENEMY_NAME = "Darth Vader";
	PLAYER_SPRITE = "smiley.png", ENEMY_SPRITE = "smiley.png";
	
	Q.state.set({playerScore: 0, enemyScore: 0, currentIndex: 0, currentQuestion: "", waiting: true});
	var deck = shuffleDeck(totalQuestions, DECK_SIZE);
	
	
	Q.UI.PlayerScore = Q.UI.Text.extend("UI.PlayerScore", { 
		init: function(p) {
			this._super(p, {
			  label: Q.state.get("playerScore") + "",
			  x: 20 * qx,
			  y: 30 * qy
			});
			Q.state.on("change.playerScore",this,"score");
		},
		
		score: function() {
			this.p.label = Q.state.get("playerScore") + "";
		}
	});
	
	Q.UI.EnemyScore = Q.UI.Text.extend("UI.EnemyScore", { 
		init: function(p) {
			this._super({
			  label: Q.state.get("enemyScore") + "",
			  x: 300 * qx,
			  y: 30 * qy
			});
			Q.state.on("change.enemyScore",this,"score");
		},
		
		score: function() {
			this.p.label = Q.state.get("enemyScore") + "";
		}
	});

	/*
	Q.UI.QuestionCounter = Q.UI.Text.extend("UI.QuestionCounter", { 
		init: function(p) {
			this._super({
			  label: "[Q: 1/" + TOTAL_QUESTIONS + "]",
			  x: 160,
			  y: 30
			});
			Q.state.on("change.currentIndex",this,"qc");
		},

		qc: function() {
			this.p.label = "[Q: " + Q.state.get("currentIndex") + "/" + TOTAL_QUESTIONS + "]";
		}
	});
	*/
	
	Q.UI.TimeCounter = Q.UI.Text.extend("UI.TimeCounter", { 
		init: function(p) {
			this._super(p, {
			  label: "n/a",
			  x: 160 * qx,
			  y: 30 * qy,
			});
		},
	});
	
	Q.PlayerPortrait = Q.Sprite.extend("PlayerPortrait", {
		init: function(p) {
			this._super(p, {
				x: 30 * qx,
				y: 530 * qy,
				scale: 0.03,
				//asset: PLAYER_SPRITE
			});
		},
	});
	
	Q.EnemyPortrait = Q.Sprite.extend("EnemyPortrait", {
		init: function(p) {
			this._super(p, {
				x: 290 * qx,
				y: 530 * qy,
				scale: 0.03,
				asset: enemySprite
			});
		},
	});
	
	Q.Bomb = Q.Sprite.extend("Bomb", {
		init: function(p) {
			this._super(p, {
				x: 160 * qx,
				y: 530 * qy,
				scale: 0.03,
				asset: BOMB_SPRITE
			});
		},
	});

    
	// Flash Card
	Q.UI.FlashCard = Q.UI.Text.extend('UI.FlashCard', {
		// default position is question
		init: function(p) {
			this._super(p, {
				color: "black",
				x: 	0,
				y: 	0,
				id: 'fc-null',
				question: 'q-null',
				answer: 'a-null',
				isQuestion: true,
				label: ""
			});
		},
	
	// load flashcard properties
		generate: function(param) {
			parsedArgument = param;			
			this.p.id = parsedArgument.id;
			this.p.question = parsedArgument.question;
			this.p.answer = parsedArgument.answer;
			if (this.p.isQuestion) {
				this.p.label = wordWrap(this.p.question, 250, 15);
			} else {
				this.p.label = this.p.answer;
			}
		},
	});
	
	//answer button
		Q.UI.AnswButton = Q.UI.Button.extend('UI.AnswButton', {
		init: function(p) {
			this._super(Q._defaults(p, {
				fill: "#FFFFFF",
				//highlight: "#FFFFFF",
				fontColor: "white",
				border: 2,
				shadow: 3,
				shadowColor: "rgba(0,0,0,0.5)",
				w: 40 * qx,
				h: 40 * qy
			}),                     
			function() {
					
			});
		},
		});
		
	// versus screen with countdown
	Q.scene("scene0", function(stage) {
		//Q.state.reset({cardSize: 12});
	
		//var cdText = stage.insert(new Q.UI.TimeCounter({x: qx*160, y: qy*284}));

		/*gtv_c = stage.insert(new Q.UI.Container({
			fill: "white",
			x: ((2/3) * 320) * qx,
			y: 90 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: (((2/3) * 320) - 20) * qx,
			h: 150 * qy
		}));*/
		
		var playerContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: ((2/3) * 320) * qx,
			y: 90 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: (((2/3) * 320) - 20) * qx,
			h: 150 * qy
		}));
		
		var enemyContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: ((2/3) * 320) * qx,
			y: 478 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: (((2/3) * 320) - 20) * qx,
			h: 150 * qy
		}));
		
		function expressStats(iName, iLevel, iTitle, iWinRate, iTotalMatches) {
			var labelStr = "[" + iName + "]" + "\n" +
			  "Level " + iLevel + " " + iTitle + "\n" +
			  "Winrate: " + iWinRate + "%" + "\n" +
			  "Total Matches: " + iTotalMatches;
			return labelStr;
		}
		
		function getWinRate(wins, total) {
			return ((wins/total)*100).toFixed(1);
		}
		
		function getLevel(accumPoints) {
			return Math.floor(accumPoints/100000);
		}
		
		//gtv_b = stage.insert(new Q.UI.Text(), gtv_c);
		var playerStats = stage.insert(new Q.UI.Text({size: 32}), playerContainer);
		var enemyStats = stage.insert(new Q.UI.Text({size: 32}), enemyContainer);
		//gtv_b.p.label = expressStats('John Smith', 23, 'Matrix Agent', 86, 305);
		playerStats.p.label = expressStats(playerName, getLevel(playerPoints), 'Matrix Agent', getWinRate(playerWin, playerTotal), playerTotal);
		enemyStats.p.label = expressStats(enemyName, getLevel(enemyPoints), 'Sith Lord', getWinRate(enemyWin, enemyTotal), enemyTotal);
		
		
		/*stage.insert(new Q.UI.Button({x: 100*qx, y: 300*qy, w: 50*qx, h: 50*qy, label: "^", fill: "white"}, 
			function() {Q.state.inc("cardSize", 1);}));
		stage.insert(new Q.UI.Button({x: 200*qx, y: 300*qy, w: 50*qx, h: 50*qy, label: "v", fill: "white"}, 
			function() {Q.state.inc("cardSize" , -1);}));
		gtv_a = stage.insert(new Q.UI.Text({x: 160*qx, y: 350 * qy, label: "test"}));
		Q.state.on("change.cardSize", function() {
			
			gtv_b.destroy(), gtv_c.destroy();
			gtv_c = stage.insert(new Q.UI.Container({
				fill: "white",
				x: ((2/3) * 320) * qx,
				y: 90 * qy,
				border: 2,
				shadow: 3,
				shadowColor: "rgba(0,0,0,0.5)",
				w: (((2/3) * 320) - 20) * qx,
				h: 150 * qy
			}));
			gtv_b = stage.insert(new Q.UI.Text({size: Q.state.get("cardSize")}), gtv_c);
			gtv_b.p.label = expressStats('John Smith', 23, 'Matrix Agent', 86, 305);
			gtv_a.p.label = Q.state.get("cardSize") + "";
		});*/
		
		var playerPortrait = stage.insert(new Q.PlayerPortrait({
			x: qx * 65, 
			y: qy * 90, 
			scale: 1, 
			asset: playerSprite,
		}));
		
		var enemyPortrait = stage.insert(new Q.EnemyPortrait({
			x: qx * 65, 
			y: qy * 478, 
			scale: 1, 
			asset: enemySprite,
		}));
		
		var matchContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: ((2/3) * 320) * qx,
			y: 284 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: (((2/3) * 320) - 20) * qx,
			h: 200 * qy
		}));
		
		function expressMatch(matchName, totalQuestions, encounterTotal, encounterWin) {
			var outStr;
			outStr = "<< Match Details >>" + "\n\n" +
			  "[" + matchName + "]" + "\n" +
			  totalQuestions + " Questions" + "\n\n";
			if (encounterTotal == 0) {
				outStr += "First Encounter!";
			} else {
				var ewr = ((encounterWin/encounterTotal) * 100).toFixed(2);
				if (ewr > 75) {
					outStr += "Deliver the Smackdown!";
				} else if (ewr < 25) {
					outStr += "Reclaim your Honor!";
				} else {
					outStr += "Struggle for Dominance!";
				}
				outStr += "\n";
				var numDenom;
				switch (encounterTotal) {
					case 1:
						numDenom = "nd";
						break;
					case 2:
						numDenom = "rd";
						break;
					default:
						numDenom = "th";
				}
				outStr += (encounterTotal + 1) + numDenom + " Encounter" + "\n" +
				  ewr + "% success rate";
			}
			return outStr;
		}
		
		var loadContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: 65 * qx,
			y: 284 * qy,
			w: 80 * qx,
			h: 202 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
		}));
		
		var loadBox = [], numBox = 21, midNum = Math.floor(numBox/2), incLvl = Math.floor((numBox - 1) / 2);
		for (i=0;i<numBox;i++) {
			loadBox[i] = stage.insert(new Q.UI.Container({
				fill: "white",
				x: 65 * qx,
				y: (184 + (100/numBox) + (i * (200/numBox))) * qy,
				w: 78 * qx,
				h: (200/numBox) * qy,
			}));
		}
		loadBox[midNum].p.fill = "green";
		
		var timerBox = stage.insert(new Q.UI.Container({
			fill: "white",
			x: (65) * qx,
			y: (284) * qy,
			w: 40 * qx,
			h: 40 * qy,
			border: 1,
		}));
		
		var timerCD = stage.insert(new Q.UI.Text({size: 50, label: ""}), timerBox);
		
		var matchDetails = stage.insert(new Q.UI.Text({size: 28}), matchContainer);
		matchDetails.p.label = expressMatch(matchName, totalQuestions, encounterTotal, encounterWin);
		
		var cdSec = 3;
		var cdTimer = new Countdown({
			seconds: cdSec,
			onUpdateStatus: function(sec) {
				var ceilSec = Math.ceil(sec);
				var incCS = cdSec - ceilSec;
				loadBox[midNum + incCS].p.fill = "green";
				loadBox[midNum - incCS].p.fill = "green";
				timerCD.p.label = ceilSec + "";
			},
			onCounterEnd: function() {
				setTimeout(function() {Q.stageScene("scene1");}, 1000);
			}
		});
		
		cdTimer.start();
	});
	
	// set scene
	Q.scene("scene1",function(stage) {
	
		Q.state.reset({playerScore: 0, enemyScore: 0, currentIndex: 0, currentQuestion: "", waiting: true});
	
		var playerScore = stage.insert(new Q.UI.PlayerScore());
		var enemyScore = stage.insert(new Q.UI.EnemyScore());
		//var leQC = stage.insert(new Q.UI.QuestionCounter());
		var leTC = stage.insert(new Q.UI.TimeCounter());
		var ansDeck;
		var isPhaseOne = true;
		var timeTakenCurrent = 0;
		
		// start receive serverForm
		var serverJSON, fcQuestion, fcAnswers, questionNumber = "0", maxTimeAllowed, prevPlayerAns, prevEnemyAns;
		/*var serverJSON = JSON.parse(TestServerForm[0]);
		var fcQuestion = serverJSON.question,
		  fcAnswers = serverJSON.answers,
		  questionNumber = serverJSON.index,
		  maxTimeAllowed = serverJSON.time,
		  prevPlayerAns = serverJSON.player,
		  prevEnemyAns = serverJSON.enemy;*/
		var currentFcAnswer, prevFcQuestion;
		//Q.state.set("currentQuestion", fcQuestion.id);
		// end receive serverForm
		
		function generateAnswers() {
			Q.state.set("waiting", false);
			var aBtns = [];
			var k = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					var fcAns = fcAnswers[k].answer;
					var ansColor = "red";
					if (fcQuestion.id == fcAnswers[k].id) {
						ansColor = "green";
					}
					aBtns[k] = stage.insert(new Q.UI.Button({
						fill: "gray",
						highlight: ansColor,
						fontColor: "white",
						x: (85 + (140*j)) * qx,
						y: (320 + (120*i)) * qy,
						border: 2,
						shadow: 3,
						shadowColor: "rgba(0,0,0,0.5)",
						w: 110 * qx,
						h: 100 * qy,
						label: fcAns,
						counter: k,
						customId: fcAnswers[k].id,
						}, function() {
							// do something
							if (!Q.state.get("waiting")) {
								timeTakenCurrent = TIMER.getTime() + "";
								Q.state.set("waiting", true);
							
								var k = this.p.counter;
								if (fcQuestion.id == fcAnswers[k].id) {
									console.log("Placeholder Trigger: Correct");
									playerCounters[Q.state.get("currentIndex") - 1].p.fill = "green";
									this.p.fill = "green";
									Q.state.inc("playerScore", 1);
								} else {
									console.log("Placeholder Trigger: Wrong");
									playerCounters[Q.state.get("currentIndex") - 1].p.fill = "red";
									this.p.fill = "red";
								}
								
								currentFcAnswer = this.p.customId;
								//Q.state.inc("currentIndex", 1);
								
								
								
								// send form to server and wait for next
								clientJSON = createClientToServerJSON(fcQuestion.id, currentFcAnswer, timeTakenCurrent, Q.state.get("currentIndex") + "");
								console.log("Post to Server: " + clientJSON);
								//socket.emit("readanswer", clientJSON);
								
							}
					}));
					
					k++;
				}
			}
			
			return aBtns;
		}
		
		function outOfTime() {
			if (!Q.state.get("waiting")) {
			Q.state.set("waiting", true);
			timeTakenCurrent = maxTimeAllowed;
			currentFcAnswer = "nothing";
			clientJSON = createClientToServerJSON(fcQuestion.id, currentFcAnswer, timeTakenCurrent, Q.state.get("currentIndex") + "");
			console.log("Post to Server: " + clientJSON);
			//socket.emit("readanswer", clientJSON);
			}
		}
		
		/*
		function generateAnswers() {
			ansDeck = dealAnswers(deck[Q.state.get("currentIndex") - 1], DECK_SIZE);
		
			var aBtns = [];
			var k = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					var fcAns = JSON.parse(getFlashCard(FLASH_SET, ansDeck[k])).answer;
					var ansColor = "red";
					if (deck[Q.state.get("currentIndex") - 1] == ansDeck[k]) {
						ansColor = "green";
					}
					aBtns[k] = stage.insert(new Q.UI.Button({
						fill: "gray",
						highlight: ansColor,
						fontColor: "white",
						x: 90 + (140*j),
						y: 320 + (120*i),
						border: 2,
						shadow: 3,
						shadowColor: "rgba(0,0,0,0.5)",
						w: 110,
						h: 100,
						label: fcAns,
						name: k
						}, function() {
							// do something
							if (deck[Q.state.get("currentIndex") - 1] == ansDeck[this.p.name]) {
								console.log("Placeholder Trigger: Correct");
								playerCounters[Q.state.get("currentIndex") - 1].p.fill = "green";
								Q.state.inc("playerScore", 1);
							} else {
								console.log("Placeholder Trigger: Wrong");
								playerCounters[Q.state.get("currentIndex") - 1].p.fill = "red";
							}
							
							Q.state.inc("currentIndex", 1);
							TIMER.start();
					}));
					k = k + 1;
				}
			}
			return aBtns;
		}
		*/
		
		function destroyAnswers(aBtns) {
			for (i=0;i<aBtns.length;i++) {
				aBtns[i].destroy();
			}
		}
		
		// player/enemy's counters
		// x = 15/305; y = 280; w = 15; h = 420; border: 2
		// boundary for y: from 70 to 490; origin is centre
		
		for (i=0;i<totalQuestions;i++) {
			playerCounters[i] = stage.insert(new Q.UI.Container({
				fill: "white",
				x: 15 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/totalQuestions) - (i*(420/totalQuestions))) * qy,
				h: (420/totalQuestions) * qy
			}));
			
			enemyCounters[i] = stage.insert(new Q.UI.Container({
				fill: "white",
				x: 305 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/totalQuestions) - (i*(420/totalQuestions))) * qy,
				h: (420/totalQuestions) * qy
			}));
		}

	
		//current question
		var qContainer = stage.insert(new Q.UI.Container({
			fill: "gray",
			x: 160 * qx,
			y: 160 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 250 * qx,
			h: 180 * qy
		}));
		
		if (Q.state.get("currentIndex") > 0) {
		var aBtns = generateAnswers();
		var qCard = stage.insert(new Q.UI.FlashCard(),qContainer);
		qCard.generate(fcQuestion);
		}
		var qCard;
		//var qCard = stage.insert(new Q.UI.FlashCard(),qContainer);
		
		var playerPortrait = stage.insert(new Q.PlayerPortrait());
		var enemyPortrait = stage.insert(new Q.EnemyPortrait());
		//var player1 = stage.insert(new Q.PlayerPiece());
		//var player2 = stage.insert(new Q.EnemyPiece());
		var bomb = stage.insert(new Q.Bomb());
		
		var raceLine = stage.insert(new Q.UI.Container({
			fill: "black",
			// from 60 to 260
			x: 160 * qx,
			y: 550 * qy,
			w: 200 * qx,
			h: 3 * qy
		}));
		
		/*Q.state.on("change.currentIndex", function() {
			if (Q.state.get("currentIndex") > TOTAL_QUESTIONS) {
				//Q.stageScene("scene2");
			}
			
			
			
			//qCard.generate(getFlashCard(FLASH_SET, deck[Q.state.get("currentIndex") - 1]));
			//destroyAnswers(aBtns);
			//aBtns = generateAnswers();
			
			
		});*/
		
	// include an event handler, when receive from server, set variables, then set "received" to true.
	
		/*socket.on('nextQuestion', function(msg) {
            //$('#log').append('<br>Received #' + msg.count + ': ' + msg.data);
			//Q.state.set("received", true);
			if (Q.state.get("currentIndex") > 0) {prevFcQuestion = fcQuestion};
			serverJSON = JSON.parse(msg.data);
			fcQuestion = serverJSON.question,
			  fcAnswers = serverJSON.answers,
			  questionNumber = parseInt(serverJSON.index),
			  maxTimeAllowed = parseInt(serverJSON.time),
			  prevPlayerAns = serverJSON.player,
			  prevEnemyAns = serverJSON.enemy;
			 Q.state.inc("currentIndex", 1);
			 console.log("yatish socket received: " + msg.data);
        });*/
		
		/*socket.on('gameOver', function(msg) {
			console.log(msg.data);
		});*/
			
	
		Q.state.on("change.currentIndex", function() {
			
			//console.log(serverJSON);
		
			if (Q.state.get("currentIndex") >= questionNumber) {
			// this part should be in above handler:
				 if (Q.state.get("currentIndex") > 1) {prevFcQuestion = fcQuestion};
				
				
				if (Q.state.get("currentIndex") <= totalQuestions) {
				serverJSON = JSON.parse(TestServerForm[parseInt(questionNumber)]);
				fcQuestion = serverJSON.question,
				  fcAnswers = serverJSON.answers,
				  questionNumber = parseInt(serverJSON.index),
			  	  maxTimeAllowed = parseInt(serverJSON.time),
				  prevPlayerAns = serverJSON.player,
				  prevEnemyAns = serverJSON.enemy;
				} else {
				prevPlayerAns = null;
				prevEnemyAns = JSON.parse(createFlashCard('test:'+m, m + ' x 1 = ??', m.toString()));
				
				}
				
				  


			// express enemy previous answer
			if (Q.state.get("currentIndex") > 1) {
				if (prevFcQuestion.id == prevEnemyAns) {
					enemyCounters[Q.state.get("currentIndex") - 2].p.fill = "green";
					Q.state.inc("enemyScore", 1);
				} else {
					enemyCounters[Q.state.get("currentIndex") - 2].p.fill = "red";
				}
			}

			
				
			// result in bomb movement
				var remainingQ = totalQuestions - Q.state.get("currentIndex") + 1;
				var scoreDiff = Q.state.get("playerScore") - Q.state.get("enemyScore");
				if (remainingQ > 0) {
					if (scoreDiff <= remainingQ) {
						bomb.p.x = (160 + ((scoreDiff/remainingQ)*100)) * qx;
					} else if (scoreDiff > remainingQ) {
						if (isPhaseOne) {
							// initiate Phase 2
							bomb.destroy();
							alert("Phase Two");
						}
					}
				} else {
					// game over
					alert("game over");
				}
				
				
				
				// game over
				//if (Q.state.get("currentIndex") > totalQuestions) {
				//	alert("GAME OVER");
				//	//Q.stageScene("scene2");
				//}
			
			// start next question
			if (Q.state.get("currentIndex") == 1) {
				qCard = stage.insert(new Q.UI.FlashCard(),qContainer);
			}
				qCard.generate(fcQuestion);
				
			

			if (Q.state.get("currentIndex") > 1) destroyAnswers(aBtns);
				aBtns = generateAnswers();

								
			}
			if (Q.state.get("currentIndex") > 1) {TIMER.stop();}
			if (Q.state.get("currentIndex") > 0 && Q.state.get("currentIndex") <= totalQuestions) {
				
				TIMER = new Countdown({
					seconds: maxTimeAllowed,
					onUpdateStatus: function(sec) {leTC.p.label = sec + "";},
					onCounterEnd: function() {outOfTime();}
				});
				TIMER.start();
			}

			
			
		});

		setTimeout(function() {
		var whiteScreen = stage.insert(new Q.UI.WhiteOut());
		var nuclearExplosion = stage.insert(new Q.Nuke());
		}, 1000);
	});
	
	// set scene
	Q.scene("scene2",function(stage) {
	
		//var leScore = stage.insert(new Q.UI.PlayerScore());
		
		var ResultsBanner = stage.insert(new Q.UI.Button({
			fill: "white",
			fontColor: "black",
			border: 2,
			shadow: 3,
			x: (160) * qx,
			y: 48 * qy,
			w: 290 * qx,
			h: 60 * qy,
			label: 'Glorious Victory/Defeat',
		}));
		
		var PlayerPointsBox = stage.insert(new Q.UI.Container({
			fill: "white",
			border: 2,
			x: 73 * qx,
			y: 103.5 * qy,
			w: 116 * qx,
			h: 50 * qy,
		}));
		
		var PlayerPointsText = stage.insert(new Q.UI.Text({label: "99.99"}),PlayerPointsBox);
		
		var VersusBox = stage.insert(new Q.UI.Button({
			fill: "white",
			border: 2,
			x: 160 * qx,
			y: 103.5 * qy,
			w: 58 * qx,
			h: 50 * qy,
			label: "VS",
		}));
		
		var EnemyPointsBox = stage.insert(new Q.UI.Container({
			fill: "white",
			border: 2,
			x: 247 * qx,
			y: 103.5 * qy,
			w: 116 * qx,
			h: 50 * qy,
		}));
		
		var ResultsCanvas = stage.insert(new Q.UI.Container({
			fill: "white",
			border: 2,
			shadow: 3,
			x: (160) * qx,
			y: (284) * qy,
			w: 290 * qx,
			h: 310 * qy,
			shadowColor: "rgba(0,0,0,0.5)",
		}));
		
		var TextResultsContainer = stage.insert(new Q.UI.Container({
			fill: "yellow",
			opacity: 0.5,
			x: (160) * qx,
			y: (181) * qy,
			w: 290 * qx,
			h: 103 * qy,
		}));
		
		var TextResults = stage.insert(new Q.UI.Text({label: ""}), TextResultsContainer);
		TextResults.p.label = "XP: +50" + "\n" + "Avg W/R: +8.75%";
		
		var GraphResultsContainer = stage.insert(new Q.UI.Container({
			fill: "blue",
			opacity: 0.5,
			x: (160) * qx,
			y: (336) * qy,
			w: 290 * qx,
			h: 207 * qy,
		}));
	
		var ReviewBtn = stage.insert(new Q.UI.Button({
			fill: "white",
			fontColor: "black",
			highlight: "gray",
			x: (320/4) * qx,
			y: 500 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 130 * qx,
			h: 100,
			label: 'Review',
		}, function() {
			Q.stageScene("scene3");
		}));
		
		var BackBtn = stage.insert(new Q.UI.Button({
			fill: "white",
			fontColor: "black",
			highlight: "gray",
			x: (3/4) * 320 * qx,
			y: 500 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 130 * qx,
			h: 100,
			label: 'Back',
		}, function() {
			// return to interface
			window.location.href="study.html";
		}));
		
		
		
	});

	
	Q.scene("scene3", function(stage) {
	
		// scene-local variables
		var passive_opacity = 0.3;
	
		// create testBattleLibrary
		
		testBL = [{totalQuestions: 3}, 
		  {question: JSON.parse(createFlashCard("101", "ajdks asdasd kasdjdjjd ajssjdaask jkajigrjgdnkjfg dfgj", "fnsdjfjh seifksdf")),
		    answers: [JSON.parse(createFlashCard("101", "ajdks asdasd kasdjdjjd ajssjdaask jkajigrjgdnkjfg dfgj", "fnsdjfjh seifksdf")), 
			  JSON.parse(createFlashCard("102", "B", "B")),
			  JSON.parse(createFlashCard("103", "C", "C")),
			  JSON.parse(createFlashCard("104", "D", "D")),],
			player: "null",
			enemy: "102",
			ptime: 10000,
			etime: 2000}, 
		  {question: JSON.parse(createFlashCard("201", "AA", "AA")),
		    answers: [JSON.parse(createFlashCard("201", "AA", "AA")), 
			  JSON.parse(createFlashCard("202", "BB", "BB")),
			  JSON.parse(createFlashCard("203", "CC", "CC")),
			  JSON.parse(createFlashCard("204", "DD", "DD")),],
			player: "203",
			enemy: "201",
			ptime: 3000,
			etime: 4000}, 
		  {question: JSON.parse(createFlashCard("301", "AAA", "AAA")),
		    answers: [JSON.parse(createFlashCard("301", "AAA", "AAA")), 
			  JSON.parse(createFlashCard("302", "BBB", "BBB")),
			  JSON.parse(createFlashCard("303", "CCC", "CCC")),
			  JSON.parse(createFlashCard("304", "DDD", "DDD")),],
			player: "301",
			enemy: "304",
			ptime: 5000,
			etime: 6000}];
			
			battleLibrary = testBL;
	
			
			
		function generateAnswers() {
			var aBtns = [];
			var k = 0;
			
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					var fillColor = "white", wordColor = "black";
					if (fcQuestion.id == fcAnswers[k].id) {
						fillColor = "green";
						wordColor = "white";
					} else {
						if (fcAnswers[k].id == pAnswer || fcAnswers[k].id == eAnswer) {
							fillColor = "red";
							wordColor = "white";
						}
					}
					
					
					aBtns[k] = stage.insert(new Q.UI.Button({
						fill: fillColor,
						//highlight: ansColor,
						fontColor: wordColor,
						x: (90 + (140*j)) * qx,
						y: (320 + (120*i)) * qy,
						border: 2,
						shadow: 3,
						shadowColor: "rgba(0,0,0,0.5)",
						w: 110 * qx,
						h: 100 * qy,
						counter: k,
						customId: fcAnswers[k].id,
						}, function() {
							// do something
					}));
					
					
					//console.log(k);
					
					//globalTestVar = fcAns;
					//console.log(wordWrap(fcAns, 110, 7));
					//console.log(fcAns);
					
					/*stage.insert(new Q.UI.Text({
						x: (90 + (140*j)) * qx,
						y: (320 + (120*i)) * qy,
						label: ""
					}));*/
					
					k++;
				}
			}

			return aBtns;
		}
		
		function generateTabs() {
			var aTabs = [];
			var k = 0, ka = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					for (l=0;l<2;l++) {
						var fcAns = fcAnswers[ka];
						var fillColor = "white";
						if ((l == 0 && fcAns.id == pAnswer) || 
						  (l == 1 && fcAns.id == eAnswer)) {
							fillColor = "gray";
							
							
						
						aTabs[aTabs.length] = stage.insert(new Q.UI.Container({
							fill: fillColor,							
							x: (62.5 + (140*j) + (55*l)) * qx,
							y: (265 + (120*i)) * qy,
							border: 2,
							shadow: 3,
							shadowColor: "rgba(0,0,0,0.5)",
							w: 55 * qx,
							h: 10 * qy,
						}));
						
						k++;
						}
					}
					ka++;
				}
			}
			
			return aTabs;
		}
		
		function destroyAnswers(aBtns, aTabs, aCont, aLab) {
			for (i=0;i<aBtns.length;i++) {
				aBtns[i].destroy();
			}
			for (j=0;j<aTabs.length;j++) {
				aTabs[j].destroy();
			}
			for (i=0;i<aCont.length;i++) {
				aCont[i].destroy();
			}
			for (i=0;i<aLab.length;i++) {
				aLab[i].destroy();
			}
		}
	
		// battleLibrary[0] = totalQuestions, enemyName
		// battleLibrary[i] = question, answers, player, enemy, ptime, etime
	
		Q.state.reset({battleIndex: 0, totalIndex: 0});
		Q.state.set("totalIndex", battleLibrary[0].totalQuestions);
		
		
		var fcQuestion, fcAnswers, pAnswer, eAnswer, pTime, eTime, aBtns, aTabs;
	
		Q.state.on("change.battleIndex", function() {
			battlePage = battleLibrary[Q.state.get("battleIndex")];
			fcQuestion = battlePage.question;
			fcAnswers = battlePage.answers;
			pAnswer = battlePage.player; // id
			eAnswer = battlePage.enemy; // id
			pTime = battlePage.ptime;
			eTime = battlePage.etime;
			
			if (aBtns != null && aTabs != null && aContainer != null && aBtnLabel != null) {
				destroyAnswers(aBtns, aTabs, aContainer, aBtnLabel);
			}
			if (qCard != null) {qCard.destroy();}
			if (PrevQBtn != null) {PrevQBtn.destroy();}
			if (NextQBtn != null) {NextQBtn.destroy();}
			
			qCard = stage.insert(new Q.UI.FlashCard(), qContainer);
			qCard.generate(fcQuestion);
			
			aBtns = generateAnswers();
			aTabs = generateTabs();
			aContainer = generateAContainer();
			aBtnLabel = generateALabel(aContainer);
			for (i=0;i<4;i++) {
				//aBtnLabel[i].p.label = wordWrap(fcAnswers[i].answer, 110, 10);
				if (fcQuestion.id == fcAnswers[i].id) {
					aBtnLabel[i].p.color = "white";
				} else {
					if (fcAnswers[i].id == pAnswer || fcAnswers[i].id == eAnswer) {
						aBtnLabel[i].p.color = "white";
					}
				}
			}
			aBtnLabel[0].p.label = wordWrap(fcAnswers[0].answer, 110, 10);
			aBtnLabel[1].p.label = wordWrap(fcAnswers[1].answer, 110, 10);
			aBtnLabel[2].p.label = wordWrap(fcAnswers[2].answer, 110, 10);
			aBtnLabel[3].p.label = wordWrap(fcAnswers[3].answer, 110, 10);

			if (pAnswer == "null") {
				PTimeCounter.p.label = "None";
			} else {
				PTimeCounter.p.label = (pTime / 1000).toFixed(3) + " s";
			}
			if (eAnswer == "null") {
				ETimeCounter.p.label = "None";
			} else {
				ETimeCounter.p.label = (eTime / 1000).toFixed(3) + " s";
			}
			
			
			
			QCounter.p.label = Q.state.get("battleIndex") + " / " + Q.state.get("totalIndex");
			if (pBattleCounters.length > 0) {
				for (i=0;i<pBattleCounters.length;i++) {
					pBattleCounters[i].p.opacity = passive_opacity;
				}
				pBattleCounters[Q.state.get("battleIndex") - 1].p.opacity = 1;
			}
			if (eBattleCounters.length > 0) {
				for (i=0;i<eBattleCounters.length;i++) {
					eBattleCounters[i].p.opacity = passive_opacity;
				}
				eBattleCounters[Q.state.get("battleIndex") - 1].p.opacity = 1;
			}
			
			if (Q.state.get("battleIndex") > 1) {
				PrevQBtn = stage.insert(new Q.UI.Button({
				  fill: "white",
				  fontColor: "black",
				  highlight: "gray",
				  x: ((320/4) - 30) * qx,
				  y: 535 * qy,
				  border: 2,
				  shadow: 3,
				  shadowColor: "rgba(0,0,0,0.5)",
				  w: 70 * qx,
				  h: 40 * qy,
				  label: "< P",
				}, function() {
					Q.state.inc("battleIndex", -1);
				}));
			}
			if (Q.state.get("battleIndex") < Q.state.get("totalIndex")) {
				NextQBtn = stage.insert(new Q.UI.Button({
				  fill: "white",
				  fontColor: "black",
				  highlight: "gray",
				  x: ((0.75*320) + 30) * qx,
				  y: 535 * qy,
				  border: 2,
				  shadow: 3,
				  shadowColor: "rgba(0,0,0,0.5)",
				  w: 70 * qx,
				  h: 40 * qy,
				  label: 'N >',
				}, function() {
					Q.state.inc("battleIndex", 1);
				}));
			}
		});
	
		var qContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: 160 * qx,
			y: 160 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 250 * qx,
			h: 180 * qy
		}));
		
		var aContainer = [], aBtnLabel = [];
		
		function generateAContainer() {
			var aContainer = [];
			var k = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					aContainer[k] = stage.insert(new Q.UI.Container({
						fill: "black",
						opacity: 0,
						x: (90 + (140*j)) * qx,
						y: (320 + (120*i)) * qy,
						border: 2,
						shadow: 3,
						shadowColor: "rgba(0,0,0,0.5)",
						w: 110 * qx,
						h: 100 * qy,
					}));
					k++;
				}
			}
			return aContainer;
		}
		
		function generateALabel(array) {
			var aBtnLabel = [];
			for (i=0;i<4;i++) {
				aBtnLabel[i] = stage.insert(new Q.UI.Text({label: ""}),array[i]);
			}
			return aBtnLabel;
		}
		
		var PrevQBtn, NextQBtn, qCard;
		
		var QCounter = stage.insert(new Q.UI.Button({
			fill: "white",
			x: 160 * qx,
			y: 535 * qy,
			w: 120 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: ""
		}));
		
		var PTimeCounter = stage.insert(new Q.UI.Button({
			fill: "white",
			x: ((320/4) - 25) * qx,
			y: 35 * qy,
			w: 95 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: ""
		}));
		
		var ETimeCounter = stage.insert(new Q.UI.Button({
			fill: "white",
			x: ((0.75*320) + 25) * qx,
			y: 35 * qy,
			w: 95 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: ""
		}));
		
		var ReturnBtn = stage.insert(new Q.UI.Button({
			fill: "white",
			highlight: "gray",
			x: (320/2) * qx,
			y: 35 * qy,
			w: 80 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: "Back"
		}, function() {
			Q.stageScene("scene2");
		}));
		
		var pBattleCounters = [], eBattleCounters = [];
		Q.state.inc("battleIndex", 1);
		
		for (i=0;i<Q.state.get("totalIndex");i++) {
			var battlePage = battleLibrary[i+1];
			var playerFill = "red", enemyFill = "red";
			var playerOp = passive_opacity, enemyOp = passive_opacity;
			if (battlePage.question.id == battlePage.player) {
				playerFill = "green";
			}
			if (battlePage.question.id == battlePage.enemy) {
				enemyFill = "green";
			}
			if (i == 0) {
				playerOp = 1, enemyOp = 1;
			}
			pBattleCounters[i] = stage.insert(new Q.UI.Container({
				fill: playerFill,
				opacity: playerOp,
				x: 15 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/Q.state.get("totalIndex")) - (i*(420/Q.state.get("totalIndex")))) * qy,
				h: (420/Q.state.get("totalIndex")) * qy
			}));
			
			eBattleCounters[i] = stage.insert(new Q.UI.Container({
				fill: enemyFill,
				opacity: enemyOp,
				x: 305 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/Q.state.get("totalIndex")) - (i*(420/Q.state.get("totalIndex")))) * qy,
				h: (420/Q.state.get("totalIndex")) * qy
			}));
		}

		
	});
	
	Q.UI.WhiteOut = Q.UI.Container.extend("WhiteOut", {
		init: function(p) {
			this._super(p, {
				fill: "white",
				x: Q.width/2,
				y: Q.height/2,
				w: Q.width,
				h: Q.height,
				opacity: 1,
			});
			//Q.audio.play(NUKE_SOUND);
		},
		step: function(dt) {
			var vt = dt / 3;
			if (this.p.opacity - vt > 0.1) {
				this.p.opacity -= vt;
			} else {
				this.p.opacity = 0.1;
				//Q.audio.stop(NUKE_SOUND);
			}
		}
	});
	
	Q.Nuke = Q.Sprite.extend("Nuke", {
		init: function(p) {
			this._super(p, {
				x: Q.width/2,
				y: Q.height/2,
				asset: NUKE_SPRITE,
				scale: (Q.height / (1020 * qy))
			});
		},
		step: function(dt) {
			var vt = dt / 3;
			if (this.p.opacity - vt > 0.1) {
				this.p.opacity -= vt;
			} else {
				this.p.opacity = 0.1;
			}
		}
	});
	
	Q.scene("testScene", function(stage) {
		Q.state.reset({nuke: false});
		
		Q.state.on("change.nuke", function() {
			if (Q.state.get("nuke")) {
			// -------------------------------------------------------start
				var nuclearExplosion = stage.insert(new Q.Nuke());
				var whiteScreen = stage.insert(new Q.UI.WhiteOut());
				var noticeScreen = stage.insert(new Q.UI.Container({
					fill: "white",
					opacity: 1,
					x: Q.width / 2,
					y: Q.height / 2,
					w: 0.5 * Q.width,
					h: 0.5 * Q.height,
					label: "",
				}));
				var noticeMsg = stage.insert(new Q.UI.Text(), noticeScreen);
				noticeMsg.p.label = "-~= OWNAGE =~-" + "\n\n" + 
					"You already won,\nbut finish them off!" + "\n\n" +
					"Press to continue...";
				var noticeButton = stage.insert(new Q.UI.Button({
					fill: "white",
					opacity: 0,
					x: Q.width / 2,
					y: Q.height / 2,
					w: 0.5 * Q.width,
					h: 0.5 * Q.height,
				}, function() {
					noticeScreen.destroy();
					noticeMsg.destroy();
					this.destroy();
				}));
			// ---------------------------------------------------------end
				Q.state.set("nuke", false);
			}			
		});
	});
	
	// stage scene
	Q.load([PLAYER_SPRITE, ENEMY_SPRITE, BOMB_SPRITE, playerSprite, enemySprite, NUKE_SPRITE], function() {
		Q.stageScene("testScene");
	});
	 //setTimeout(function(){Q.state.inc("currentIndex", 1);}, 5000);
});

	function generateResultsGraph() {
		setTimeout(function() {
			canvasDOM = $('#quintus');
			canvasStyle = $('#quintus').attr('style');
			graphDiv = $('<div />').attr('id', 'overlay').attr('style', 'position:relative;top:300px;left:140px');
			graphDiv.insertBefore(canvasDOM);
			canvasDOM.attr('style', canvasStyle + 'z-index: -1;');
		}, 1000);
	}

	$(document).ready(function() {
		
	});
	  </script>
	  <!-- <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-46324526-3', 'auto');
        ga('send', 'pageview');
    </script> -->
 </body>
 
 <footer>
   <script>
	
   </script>
 </footer>
</html>>