<!DOCTYPE html>
<html>
 <head>
	<meta name="viewport" content="width=device-width, user-scalable=no" />
	<title></title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src='http://cdn.html5quintus.com/v0.2.0/quintus-all.js'></script>
	<!-- <script src='http://cdnjs.cloudflare.com/ajax/libs/socket.io/0.9.16/socket.io.min.js'></script> -->
    <!-- <script src='example1.js'></script> -->
	<link rel="stylesheet" type="text/css" href="css/singlePlayer.css">
	<script>
		var globalTestVar, gtv_a;
	
	
		// socket stuff
	/*
			namespace = '/test'; // change to an empty string to use the global namespace

            // the socket.io documentation recommends sending an explicit package upon connection
            // this is specially important when using the global namespace
            var socket = io.connect('http://' + document.domain + ':' + location.port + namespace,
                                    {"connect timeout": 300,
                                     "close timeout": 30,
                                     "hearbeat timeout": 30});
            socket.on('connect', function() {
            });
			
			 
		
		// socket handler
		socket.on('initiating', function(msg) {
                //$('#log').append('<br>Received #' + msg.count + ': ' + msg.data);
            });
	*/
		
	
		// helper functions
		
		String.prototype.insert = function (index, string) {
			  if (index > 0)
				return this.substring(0, index) + string + this.substring(index, this.length);
			  else
				return string + this;
			};
		
		function wordWrap(iStr, cardWidth, pixelPerChar) {
			var wrappedStr = iStr;
			var n = iStr.length;
			
			if ((n * pixelPerChar) > cardWidth) {
				var m = Math.floor((n * pixelPerChar)/cardWidth);
				for (i=0;i<m;i++) {
					wrappedStr = wrappedStr.insert((i+1)*(cardWidth/pixelPerChar), "\n");
				}
			}
			
			return wrappedStr;
		}
		
		function Countdown(options) {
			var timer,
			  instance = this,
			  seconds = options.seconds || 10,
			  updateStatus = options.onUpdateStatus || function () {},
			  counterEnd = options.onCounterEnd || function () {},
			  offset, max;
			  
			function decrementCounter() {
				d = delta();
				seconds = (seconds >= d) ? seconds -= d : 0;
				updateStatus((seconds/1000).toFixed(2));
				if (seconds <= 0) {
					counterEnd();
					instance.stop();
				}
			}
			
			function delta() {
				var now = Date.now(),
				  d = now - offset;
				offset = now;
				return d;
			}
			
			this.getTime = function() {
				return (max - seconds);
			};

			this.start = function () {
				clearInterval(timer);
				timer = 0;
				offset = Date.now();
				max = options.seconds * 1000;
				seconds = options.seconds * 1000;
				timer = setInterval(decrementCounter, 10);
			};

			 this.stop = function () {
				clearInterval(timer);
			};
		}
	
		function parseBool(param) {
			return (param === 'true');
		}
		
		function createFlashCard(pId, pQn, pAns) {
			var fc = JSON.stringify({
				id: pId, 
				question: pQn, 
				answer: pAns, 
			});
			return fc;
		}
		
		function createFlashSet(pId, pN, pC, pFc) {
			var fs = JSON.stringify({
				id: pId,
				name: pN,
				category: pC,
				cards: pFc
			});
			return fs;
		}
		
		function getFlashCard(flashSet, n) { // input fs and output fc all in JSON
			var fs = JSON.parse(flashSet);
			var fc = fs.cards[n];
			return fc;
		}
		
		function getDeckSize(flashSet) { // input in JSON, output in integer
			var parsedDeck = JSON.parse(flashSet);
			var n = parsedDeck.cards.length;
			return n;
		}
		
		function shuffle(array) { // http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
			var currentIndex = array.length, temporaryValue, randomIndex ;

			// While there remain elements to shuffle...
			while (0 !== currentIndex) {

				// Pick a remaining element...
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex -= 1;

				// And swap it with the current element.
				temporaryValue = array[currentIndex];
				array[currentIndex] = array[randomIndex];
				array[randomIndex] = temporaryValue;
			}

		return array;
		}
		
		/**
		 * Returns a random integer between min (inclusive) and max (inclusive)
		 * Using Math.round() will give you a non-uniform distribution!
		 */
		function getRandomInt(min, max) {
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}
		
		function shuffleDeck(x, n) { // x = decksize, n = totalsize
			var deck = [];
			for (i=0;i<n;i++) {
				deck[i] = i;
			}
			var newDeck = shuffle(deck);
			var chosenDeck = newDeck.slice(0, x);
			return chosenDeck;
		}
		
		function dealAnswers(a, n) { // a = order # of answer, n = decksize
			var deck = [];
			var iniCounter = 0;
			for (i=0;i<n;i++) {
				if (i != a) {
					deck[iniCounter] = i;
					iniCounter = iniCounter + 1;
				}
			}
			var newDeck = shuffle(deck);
			var chosenDeck = newDeck.slice(0, 3);
			var finalDeck = [];
			var hasInserted = false;
			var deckCounter = 0;
			for (i=0;i<4;i++) {
				var decision = Math.random() < 0.5;
				if (!hasInserted && (decision || i == 3)) {
					finalDeck[i] = a;
					hasInserted = true;
				} else {
					finalDeck[i] = chosenDeck[deckCounter];
					deckCounter = deckCounter + 1;
				}
			}
			return finalDeck;
		}
		
		function createClientToServerJSON(questionId, answerId, timeTaken, questionsCompleted) {
			var clientJSON = JSON.stringify({
				id: questionId,
				answer: answerId,
				time: timeTaken,
				done: questionsCompleted,
			});
			return clientJSON;
		}
		
		// some global variables
		var playerCounters = [];
		var enemyCounters = [];

		// declare JSON vars for testing purposes
		var TestFlashCard = createFlashCard('22', 'F=??', 'M x A');
		
		var TestFCArray = [];
		for (i=0;i<30;i++) {
			var stringId = i.toString();
			var stringQn = i.toString() + ' + ' + i.toString() + ' = ??';
			var stringAns = (i + i).toString();
			var fc = createFlashCard(stringId, stringQn, stringAns);
			TestFCArray[i] = fc;
		}
		var TestFlashSet = createFlashSet('101', 'Simple Additions', 'Mathematics', TestFCArray);
		var TestTotalQuestions = 10;
		
		var TestInitiatingForm = JSON.stringify({
			name: "John Smith",
			sprite: "smiley.png",
			win: "75%",
			encounter: "6",
			total: "3",
		});
		
		var TestServerForm = [];
		for (i=0;i<3;i++) {
		m = getRandomInt(0, 2);
			j = i + 1, k = j + 1, l = k + 1;
			TestServerForm[i] = JSON.stringify({
				question: JSON.parse(createFlashCard('test:'+i, i + ' x 1 = ??', i.toString())),
				answers: [JSON.parse(createFlashCard('test:'+i, i + ' x 1 = ??', i.toString())), 
				  JSON.parse(createFlashCard('test:'+j, i + ' x 1 = ??', j.toString())), 
				  JSON.parse(createFlashCard('test:'+k, i + ' x 1 = ??', k.toString())), 
				  JSON.parse(createFlashCard('test:'+l, i + ' x 1 = ??', l.toString()))],
				index: "" + (i + 1),
				time: "" + 5,
				player: null,
				enemy: JSON.parse(createFlashCard('test:'+m, m + ' x 1 = ??', m.toString())),
			});
		}
		
		// fetching info from server
		var INITIATING_FORM, SERVER_FORM;
		
		// Start load test
			INITIATING_FORM = TestInitiatingForm;
			
		// End load test

		var FLASH_SET = TestFlashSet;
		var DECK_SIZE = getDeckSize(FLASH_SET);
		var TOTAL_QUESTIONS = TestTotalQuestions;
		var PLAYER_SPRITE = "smiley.png";
		var ENEMY_SPRITE = "smiley.png";
		var BOMB_SPRITE = "bomb.png";
		var QUESTION_TIME = 10;
		var CURRENT_TIME = QUESTION_TIME;
		var TIMER;
		
		// interpreting info from server
		var initiatingJSON = JSON.parse(INITIATING_FORM);
		console.log(initiatingJSON);
		var playerName, playerSprite, playerPoints, playerWin, playerTotal;
		var enemyName, enemySprite, enemyPoints, enemyWin, enemyTotal;
		var encounterTotal, encounterWin, matchName, totalQuestions;
		
		var battleLibrary = []
		function createBattle(fcQ, fcA, playerA, enemyA, playerTime, enemyTime) {
			var battlePage = {
				question: fcQ,
				answers: fcA,
				player: playerA,
				enemy: enemyA,
				ptime: playerTime,
				etime: enemyTime,
			}
			return battlePage;
		}
		
	</script>
 </head>
 
 <body>
	<script>
	window.addEventListener("load",function() {
		//setTimeout(function() {
		//	socket.emit('assignroom', {flashset: "quizlet:39748410", user1: "quizlet:yatish", user2: "quizlet:byatishyuvaraj"});
		//}, 10000);
	var Q = window.Q = Quintus()
    .include("Sprites, Scenes, Input, 2D, Anim, Touch, UI")
    .setup({
		//width: 300,
		//height: 675,
		//scaleToFit: true
		maximize: true
	}).touch();
	
	// dynamic vars
	var qx = Q.width/320;
	var qy = Q.height/568;
	
	// load initiating form here
	playerName = initiatingJSON.playerName;
	playerSprite = initiatingJSON.playerSprite;
	playerPoints = initiatingJSON.playerPoints;
	playerWin = initiatingJSON.playerWin;
	playerTotal = initiatingJSON.playerTotal;
	enemyName = initiatingJSON.enemyName;
	enemySprite = initiatingJSON.enemySprite;
	enemyPoints = initiatingJSON.enemyPoints;
	enemyWin = initiatingJSON.enemyWin;
	enemyTotal = initiatingJSON.enemyTotal;
	encounterTotal = initiatingJSON.encounterTotal;
	encounterWin = initiatingJSON.encounterWin;
	matchName = initiatingJSON.matchName;
	totalQuestions = initiatingJSON.totalQuestions;	  
	  
	 battleLibrary[0] = totalQuestions;

	PLAYER_NAME = "John Smith", ENEMY_NAME = "Darth Vader";
	PLAYER_SPRITE = "smiley.png", ENEMY_SPRITE = "smiley.png";
	
	Q.state.set({playerScore: 0, enemyScore: 0, currentIndex: 0, currentQuestion: "", waiting: true});
	var deck = shuffleDeck(totalQuestions, DECK_SIZE);
	
	
	Q.UI.PlayerScore = Q.UI.Text.extend("UI.PlayerScore", { 
		init: function(p) {
			this._super(p, {
			  label: Q.state.get("playerScore") + "",
			  x: 20 * qx,
			  y: 30 * qy
			});
			Q.state.on("change.playerScore",this,"score");
		},
		
		score: function() {
			this.p.label = Q.state.get("playerScore") + "";
		}
	});
	
	Q.UI.EnemyScore = Q.UI.Text.extend("UI.EnemyScore", { 
		init: function(p) {
			this._super({
			  label: Q.state.get("enemyScore") + "",
			  x: 300 * qx,
			  y: 30 * qy
			});
			Q.state.on("change.enemyScore",this,"score");
		},
		
		score: function() {
			this.p.label = Q.state.get("enemyScore") + "";
		}
	});

	/*
	Q.UI.QuestionCounter = Q.UI.Text.extend("UI.QuestionCounter", { 
		init: function(p) {
			this._super({
			  label: "[Q: 1/" + TOTAL_QUESTIONS + "]",
			  x: 160,
			  y: 30
			});
			Q.state.on("change.currentIndex",this,"qc");
		},

		qc: function() {
			this.p.label = "[Q: " + Q.state.get("currentIndex") + "/" + TOTAL_QUESTIONS + "]";
		}
	});
	*/
	
	Q.UI.TimeCounter = Q.UI.Text.extend("UI.TimeCounter", { 
		init: function(p) {
			this._super(p, {
			  label: "n/a",
			  x: 160 * qx,
			  y: 30 * qy,
			});
		},
	});
	
	Q.PlayerPortrait = Q.Sprite.extend("PlayerPortrait", {
		init: function(p) {
			this._super(p, {
				x: 30 * qx,
				y: 530 * qy,
				scale: 0.03,
				//asset: PLAYER_SPRITE
			});
		},
	});
	
	Q.EnemyPortrait = Q.Sprite.extend("EnemyPortrait", {
		init: function(p) {
			this._super(p, {
				x: 290 * qx,
				y: 530 * qy,
				scale: 0.03,
				asset: enemySprite
			});
		},
	});
	
	Q.Bomb = Q.Sprite.extend("Bomb", {
		init: function(p) {
			this._super(p, {
				x: 160 * qx,
				y: 530 * qy,
				scale: 0.03,
				asset: BOMB_SPRITE
			});
		},
	});

    
	// Flash Card
	Q.UI.FlashCard = Q.UI.Text.extend('UI.FlashCard', {
		// default position is question
		init: function(p) {
			this._super(p, {
				color: "black",
				x: 	0,
				y: 	0,
				id: 'fc-null',
				question: 'q-null',
				answer: 'a-null',
				isQuestion: true,
				label: ""
			});
		},
	
	// load flashcard properties
		generate: function(param) {
			parsedArgument = param;			
			this.p.id = parsedArgument.id;
			this.p.question = parsedArgument.question;
			this.p.answer = parsedArgument.answer;
			if (this.p.isQuestion) {
				this.p.label = wordWrap(this.p.question, 250, 15);
			} else {
				this.p.label = this.p.answer;
			}
		},
	});
	
	//answer button
		Q.UI.AnswButton = Q.UI.Button.extend('UI.AnswButton', {
		init: function(p) {
			this._super(Q._defaults(p, {
				fill: "#FFFFFF",
				//highlight: "#FFFFFF",
				fontColor: "white",
				border: 2,
				shadow: 3,
				shadowColor: "rgba(0,0,0,0.5)",
				w: 40 * qx,
				h: 40 * qy
			}),                     
			function() {
					
			});
		},
		});
		
	// versus screen with countdown
	Q.scene("scene0", function(stage) {
		Q.state.reset({cardSize: 12});
	
		var cdText = stage.insert(new Q.UI.TimeCounter({x: qx*160, y: qy*284}));

		var playerContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: ((2/3) * 320) * qx,
			y: 90 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: (((2/3) * 320) - 20) * qx,
			h: 150 * qy
		}));
		
		var enemyContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: ((2/3) * 320) * qx,
			y: 478 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: (((2/3) * 320) - 20) * qx,
			h: 150 * qy
		}));
		
		function expressStats(iName, iLevel, iTitle, iWinRate, iTotalMatches) {
			var labelStr = "[" + iName + "]" + "\n" +
			  "Level " + iLevel + " " + iTitle + "\n" +
			  "Winrate: " + iWinRate + "%" + "\n" +
			  "Total Matches: " + iTotalMatches;
			return labelStr;
		}
		
		var playerStats = stage.insert(new Q.UI.Text(), playerContainer);
		var enemyStats = stage.insert(new Q.UI.Text(), enemyContainer);
		playerStats.p.label = expressStats('John Smith', 23, 'Matrix Agent', 86, 305);
		enemyStats.p.label = expressStats('Darth Vader', 37, 'Sith Lord', 67, 1300);
		
		
		stage.insert(new Q.UI.Button({x: 100*qx, y: 300*qy, w: 50*qx, h: 50*qy, label: "^", fill: "white"}, 
			function() {Q.state.inc("cardSize", 1);}));
		stage.insert(new Q.UI.Button({x: 200*qx, y: 300*qy, w: 50*qx, h: 50*qy, label: "v", fill: "white"}, 
			function() {Q.state.inc("cardSize" , -1);}));
		gtv_a = stage.insert(new Q.UI.Text({x: 160*qx, y: 350 * qy, label: "test"}));
		Q.state.on("change.cardSize", function() {
			playerStats.p.size = Q.state.get("cardSize");
			gtv_a.p.label = Q.state.get("cardSize") + "";
		});
		
		var playerPortrait = stage.insert(new Q.PlayerPortrait({
			x: qx * (320/6), 
			y: qy * 90, 
			scale: 0.05, 
			asset: PLAYER_SPRITE,
		}));
		
		var enemyPortrait = stage.insert(new Q.EnemyPortrait({
			x: qx * (320/6), 
			y: qy * 478, 
			scale: 0.05, 
			asset: ENEMY_SPRITE
		}));
		
		
	
		var cdTimer = new Countdown({
			seconds: 10,
			onUpdateStatus: function(sec) {cdText.p.label = "Game starting in " + (Math.ceil(sec)) + " seconds."},
			onCounterEnd: function() {/*Q.stageScene("scene1");*/}
		});
		
		cdTimer.start();
	});
	
	// set scene
	Q.scene("scene1",function(stage) {
	
		Q.state.reset({playerScore: 0, enemyScore: 0, currentIndex: 0, currentQuestion: "", waiting: true});
	
		var playerScore = stage.insert(new Q.UI.PlayerScore());
		var enemyScore = stage.insert(new Q.UI.EnemyScore());
		//var leQC = stage.insert(new Q.UI.QuestionCounter());
		var leTC = stage.insert(new Q.UI.TimeCounter());
		var ansDeck;
		var isPhaseOne = true;
		var timeTakenCurrent = 0;
		
		// start receive serverForm
		var serverJSON, fcQuestion, fcAnswers, questionNumber = "0", maxTimeAllowed, prevPlayerAns, prevEnemyAns;
		/*var serverJSON = JSON.parse(TestServerForm[0]);
		var fcQuestion = serverJSON.question,
		  fcAnswers = serverJSON.answers,
		  questionNumber = serverJSON.index,
		  maxTimeAllowed = serverJSON.time,
		  prevPlayerAns = serverJSON.player,
		  prevEnemyAns = serverJSON.enemy;*/
		var currentFcAnswer, prevFcQuestion;
		//Q.state.set("currentQuestion", fcQuestion.id);
		// end receive serverForm
		
		function generateAnswers() {
			Q.state.set("waiting", false);
			var aBtns = [];
			var k = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					var fcAns = fcAnswers[k].answer;
					var ansColor = "red";
					if (fcQuestion.id == fcAnswers[k].id) {
						ansColor = "green";
					}
					aBtns[k] = stage.insert(new Q.UI.Button({
						fill: "gray",
						highlight: ansColor,
						fontColor: "white",
						x: (85 + (140*j)) * qx,
						y: (320 + (120*i)) * qy,
						border: 2,
						shadow: 3,
						shadowColor: "rgba(0,0,0,0.5)",
						w: 110 * qx,
						h: 100 * qy,
						label: fcAns,
						counter: k,
						customId: fcAnswers[k].id,
						}, function() {
							// do something
							if (!Q.state.get("waiting")) {
								timeTakenCurrent = TIMER.getTime() + "";
								Q.state.set("waiting", true);
							
								var k = this.p.counter;
								if (fcQuestion.id == fcAnswers[k].id) {
									console.log("Placeholder Trigger: Correct");
									playerCounters[Q.state.get("currentIndex") - 1].p.fill = "green";
									this.p.fill = "green";
									Q.state.inc("playerScore", 1);
								} else {
									console.log("Placeholder Trigger: Wrong");
									playerCounters[Q.state.get("currentIndex") - 1].p.fill = "red";
									this.p.fill = "red";
								}
								
								currentFcAnswer = this.p.customId;
								//Q.state.inc("currentIndex", 1);
								
								
								
								// send form to server and wait for next
								clientJSON = createClientToServerJSON(fcQuestion.id, currentFcAnswer, timeTakenCurrent, Q.state.get("currentIndex") + "");
								console.log("Post to Server: " + clientJSON);
								//socket.emit("readanswer", clientJSON);
								
							}
					}));
					
					k++;
				}
			}
			
			return aBtns;
		}
		
		function outOfTime() {
			if (!Q.state.get("waiting")) {
			Q.state.set("waiting", true);
			timeTakenCurrent = maxTimeAllowed;
			currentFcAnswer = "nothing";
			clientJSON = createClientToServerJSON(fcQuestion.id, currentFcAnswer, timeTakenCurrent, Q.state.get("currentIndex") + "");
			console.log("Post to Server: " + clientJSON);
			//socket.emit("readanswer", clientJSON);
			}
		}
		
		/*
		function generateAnswers() {
			ansDeck = dealAnswers(deck[Q.state.get("currentIndex") - 1], DECK_SIZE);
		
			var aBtns = [];
			var k = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					var fcAns = JSON.parse(getFlashCard(FLASH_SET, ansDeck[k])).answer;
					var ansColor = "red";
					if (deck[Q.state.get("currentIndex") - 1] == ansDeck[k]) {
						ansColor = "green";
					}
					aBtns[k] = stage.insert(new Q.UI.Button({
						fill: "gray",
						highlight: ansColor,
						fontColor: "white",
						x: 90 + (140*j),
						y: 320 + (120*i),
						border: 2,
						shadow: 3,
						shadowColor: "rgba(0,0,0,0.5)",
						w: 110,
						h: 100,
						label: fcAns,
						name: k
						}, function() {
							// do something
							if (deck[Q.state.get("currentIndex") - 1] == ansDeck[this.p.name]) {
								console.log("Placeholder Trigger: Correct");
								playerCounters[Q.state.get("currentIndex") - 1].p.fill = "green";
								Q.state.inc("playerScore", 1);
							} else {
								console.log("Placeholder Trigger: Wrong");
								playerCounters[Q.state.get("currentIndex") - 1].p.fill = "red";
							}
							
							Q.state.inc("currentIndex", 1);
							TIMER.start();
					}));
					k = k + 1;
				}
			}
			return aBtns;
		}
		*/
		
		function destroyAnswers(aBtns) {
			for (i=0;i<aBtns.length;i++) {
				aBtns[i].destroy();
			}
		}
		
		// player/enemy's counters
		// x = 15/305; y = 280; w = 15; h = 420; border: 2
		// boundary for y: from 70 to 490; origin is centre
		
		for (i=0;i<totalQuestions;i++) {
			playerCounters[i] = stage.insert(new Q.UI.Container({
				fill: "white",
				x: 15 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/totalQuestions) - (i*(420/totalQuestions))) * qy,
				h: (420/totalQuestions) * qy
			}));
			
			enemyCounters[i] = stage.insert(new Q.UI.Container({
				fill: "white",
				x: 305 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/totalQuestions) - (i*(420/totalQuestions))) * qy,
				h: (420/totalQuestions) * qy
			}));
		}

	
		//current question
		var qContainer = stage.insert(new Q.UI.Container({
			fill: "gray",
			x: 160 * qx,
			y: 160 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 250 * qx,
			h: 180 * qy
		}));
		
		if (Q.state.get("currentIndex") > 0) {
		var aBtns = generateAnswers();
		var qCard = stage.insert(new Q.UI.FlashCard(),qContainer);
		qCard.generate(fcQuestion);
		}
		var qCard;
		//var qCard = stage.insert(new Q.UI.FlashCard(),qContainer);
		
		var playerPortrait = stage.insert(new Q.PlayerPortrait());
		var enemyPortrait = stage.insert(new Q.EnemyPortrait());
		//var player1 = stage.insert(new Q.PlayerPiece());
		//var player2 = stage.insert(new Q.EnemyPiece());
		var bomb = stage.insert(new Q.Bomb());
		
		var raceLine = stage.insert(new Q.UI.Container({
			fill: "black",
			// from 60 to 260
			x: 160 * qx,
			y: 550 * qy,
			w: 200 * qx,
			h: 3 * qy
		}));
		
		/*Q.state.on("change.currentIndex", function() {
			if (Q.state.get("currentIndex") > TOTAL_QUESTIONS) {
				//Q.stageScene("scene2");
			}
			
			
			
			//qCard.generate(getFlashCard(FLASH_SET, deck[Q.state.get("currentIndex") - 1]));
			//destroyAnswers(aBtns);
			//aBtns = generateAnswers();
			
			
		});*/
		
	// include an event handler, when receive from server, set variables, then set "received" to true.
	
		/*socket.on('nextQuestion', function(msg) {
            //$('#log').append('<br>Received #' + msg.count + ': ' + msg.data);
			//Q.state.set("received", true);
			if (Q.state.get("currentIndex") > 0) {prevFcQuestion = fcQuestion};
			serverJSON = JSON.parse(msg.data);
			fcQuestion = serverJSON.question,
			  fcAnswers = serverJSON.answers,
			  questionNumber = parseInt(serverJSON.index),
			  maxTimeAllowed = parseInt(serverJSON.time),
			  prevPlayerAns = serverJSON.player,
			  prevEnemyAns = serverJSON.enemy;
			 Q.state.inc("currentIndex", 1);
			 console.log("yatish socket received: " + msg.data);
        });*/
		
		/*socket.on('gameOver', function(msg) {
			console.log(msg.data);
		});*/
			
	
		Q.state.on("change.currentIndex", function() {
			
			//console.log(serverJSON);
		
			if (Q.state.get("currentIndex") >= questionNumber) {
			// this part should be in above handler:
				 if (Q.state.get("currentIndex") > 1) {prevFcQuestion = fcQuestion};
				
				
				if (Q.state.get("currentIndex") <= totalQuestions) {
				serverJSON = JSON.parse(TestServerForm[parseInt(questionNumber)]);
				fcQuestion = serverJSON.question,
				  fcAnswers = serverJSON.answers,
				  questionNumber = parseInt(serverJSON.index),
			  	  maxTimeAllowed = parseInt(serverJSON.time),
				  prevPlayerAns = serverJSON.player,
				  prevEnemyAns = serverJSON.enemy;
				} else {
				prevPlayerAns = null;
				prevEnemyAns = JSON.parse(createFlashCard('test:'+m, m + ' x 1 = ??', m.toString()));
				
				}
				
				  


			// express enemy previous answer
			if (Q.state.get("currentIndex") > 1) {
				if (prevFcQuestion.id == prevEnemyAns) {
					enemyCounters[Q.state.get("currentIndex") - 2].p.fill = "green";
					Q.state.inc("enemyScore", 1);
				} else {
					enemyCounters[Q.state.get("currentIndex") - 2].p.fill = "red";
				}
			}

			
				
			// result in bomb movement
				var remainingQ = totalQuestions - Q.state.get("currentIndex") + 1;
				var scoreDiff = Q.state.get("playerScore") - Q.state.get("enemyScore");
				if (remainingQ > 0) {
					if (scoreDiff <= remainingQ) {
						bomb.p.x = (160 + ((scoreDiff/remainingQ)*100)) * qx;
					} else if (scoreDiff > remainingQ) {
						if (isPhaseOne) {
							// initiate Phase 2
							bomb.destroy();
							alert("Phase Two");
						}
					}
				} else {
					// game over
					alert("game over");
				}
				
				
				
				// game over
				//if (Q.state.get("currentIndex") > totalQuestions) {
				//	alert("GAME OVER");
				//	//Q.stageScene("scene2");
				//}
			
			// start next question
			if (Q.state.get("currentIndex") == 1) {
				qCard = stage.insert(new Q.UI.FlashCard(),qContainer);
			}
				qCard.generate(fcQuestion);
				
			

			if (Q.state.get("currentIndex") > 1) destroyAnswers(aBtns);
				aBtns = generateAnswers();

								
			}
			if (Q.state.get("currentIndex") > 1) {TIMER.stop();}
			if (Q.state.get("currentIndex") > 0 && Q.state.get("currentIndex") <= totalQuestions) {
				
				TIMER = new Countdown({
					seconds: maxTimeAllowed,
					onUpdateStatus: function(sec) {leTC.p.label = sec + "";},
					onCounterEnd: function() {outOfTime();}
				});
				TIMER.start();
			}

			
			
		});

	});
	
	// set scene
	Q.scene("scene2",function(stage) {
	
		//var leScore = stage.insert(new Q.UI.PlayerScore());
		
		var ResultsBanner = stage.insert(new Q.UI.Button({
			fill: "white",
			fontColor: "black",
			border: 2,
			shadow: 3,
			x: (320/2) * qx,
			y: 48 * qy,
			w: 290 * qx,
			h: 60 * qy,
			label: 'Glorious Victory/Defeat',
		}));
		
		var ResultsBox = stage.insert(new Q.UI.Container({
			fill: "white",
			fontColor: "black",
			border: 2,
			shadow: 3,
			x: (320/2) * qx,
			y: (((450-78)/2)+78) * qy,
			w: 290 * qx,
			h: 350 * qy,
		}));
	
		var ReviewBtn = stage.insert(new Q.UI.Button({
			fill: "white",
			fontColor: "black",
			highlight: "gray",
			x: (320/4) * qx,
			y: 500 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 130 * qx,
			h: 100,
			label: 'Review',
		}, function() {
			Q.stageScene("scene3");
		}));
		
		var BackBtn = stage.insert(new Q.UI.Button({
			fill: "white",
			fontColor: "black",
			highlight: "gray",
			x: (3/4) * 320 * qx,
			y: 500 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 130 * qx,
			h: 100,
			label: 'Back',
		}, function() {
			// return to interface
			window.location.href="study.html";
		}));
		
		
		
	});

	
	Q.scene("scene3", function(stage) {
	
		// scene-local variables
		var passive_opacity = 0.3;
	
		// create testBattleLibrary
		
		testBL = [{totalQuestions: 3}, 
		  {question: JSON.parse(createFlashCard("101", "ajdks asdasd kasdjdjjd ajssjdaask jkajigrjgdnkjfg dfgj", "fnsdjfjh seifksdf")),
		    answers: [JSON.parse(createFlashCard("101", "ajdks asdasd kasdjdjjd ajssjdaask jkajigrjgdnkjfg dfgj", "fnsdjfjh seifksdf")), 
			  JSON.parse(createFlashCard("102", "B", "B")),
			  JSON.parse(createFlashCard("103", "C", "C")),
			  JSON.parse(createFlashCard("104", "D", "D")),],
			player: "null",
			enemy: "102",
			ptime: 10000,
			etime: 2000}, 
		  {question: JSON.parse(createFlashCard("201", "AA", "AA")),
		    answers: [JSON.parse(createFlashCard("201", "AA", "AA")), 
			  JSON.parse(createFlashCard("202", "BB", "BB")),
			  JSON.parse(createFlashCard("203", "CC", "CC")),
			  JSON.parse(createFlashCard("204", "DD", "DD")),],
			player: "203",
			enemy: "201",
			ptime: 3000,
			etime: 4000}, 
		  {question: JSON.parse(createFlashCard("301", "AAA", "AAA")),
		    answers: [JSON.parse(createFlashCard("301", "AAA", "AAA")), 
			  JSON.parse(createFlashCard("302", "BBB", "BBB")),
			  JSON.parse(createFlashCard("303", "CCC", "CCC")),
			  JSON.parse(createFlashCard("304", "DDD", "DDD")),],
			player: "301",
			enemy: "304",
			ptime: 5000,
			etime: 6000}];
			
			battleLibrary = testBL;
	
			
			
			function generateAnswers() {
			var aBtns = [];
			var k = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					var fcAns = fcAnswers[k].answer;
					var fillColor = "white", wordColor = "black";
					if (fcQuestion.id == fcAnswers[k].id) {
						fillColor = "green";
						wordColor = "white";
					} else {
						if (fcAnswers[k].id == pAnswer || fcAnswers[k].id == eAnswer) {
							fillColor = "red";
							wordColor = "white";
						}
					}
					
					aBtns[k] = stage.insert(new Q.UI.Button({
						fill: fillColor,
						//highlight: ansColor,
						fontColor: wordColor,
						x: (90 + (140*j)) * qx,
						y: (320 + (120*i)) * qy,
						border: 2,
						shadow: 3,
						shadowColor: "rgba(0,0,0,0.5)",
						w: 110 * qx,
						h: 100 * qy,
						label: fcAns,
						counter: k,
						customId: fcAnswers[k].id,
						}, function() {
							// do something
					}));
					console.log(k);
					
					globalTestVar = fcAns;
					//console.log(wordWrap(fcAns, 110, 7));
					//console.log(fcAns);
					
					stage.insert(new Q.UI.Text({
						x: (90 + (140*j)) * qx,
						y: (320 + (120*i)) * qy,
						label: ""
					}));
					
					k++;
				}
			}
			
			return aBtns;
		}
		
		function generateTabs() {
			var aTabs = [];
			var k = 0, ka = 0;
			for (i=0;i<2;i++) {
				for (j=0;j<2;j++) {
					for (l=0;l<2;l++) {
						var fcAns = fcAnswers[ka];
						var fillColor = "white";
						if ((l == 0 && fcAns.id == pAnswer) || 
						  (l == 1 && fcAns.id == eAnswer)) {
							fillColor = "gray";
							
							
						
						aTabs[aTabs.length] = stage.insert(new Q.UI.Container({
							fill: fillColor,							
							x: (62.5 + (140*j) + (55*l)) * qx,
							y: (265 + (120*i)) * qy,
							border: 2,
							shadow: 3,
							shadowColor: "rgba(0,0,0,0.5)",
							w: 55 * qx,
							h: 10 * qy,
						}));
						
						k++;
						}
					}
					ka++;
				}
			}
			
			return aTabs;
		}
		
		function destroyAnswers(aBtns, aTabs) {
			for (i=0;i<aBtns.length;i++) {
				aBtns[i].destroy();
			}
			for (j=0;j<aTabs.length;j++) {
				aTabs[j].destroy();
			}
		}
	
		// battleLibrary[0] = totalQuestions, enemyName
		// battleLibrary[i] = question, answers, player, enemy, ptime, etime
	
		Q.state.reset({battleIndex: 0, totalIndex: 0});
		Q.state.set("totalIndex", battleLibrary[0].totalQuestions);
		
		
		var fcQuestion, fcAnswers, pAnswer, eAnswer, pTime, eTime, aBtns, aTabs;
	
		Q.state.on("change.battleIndex", function() {
			battlePage = battleLibrary[Q.state.get("battleIndex")];
			fcQuestion = battlePage.question;
			fcAnswers = battlePage.answers;
			pAnswer = battlePage.player; // id
			eAnswer = battlePage.enemy; // id
			pTime = battlePage.ptime;
			eTime = battlePage.etime;
			
			if (aBtns != null && aTabs != null) {destroyAnswers(aBtns, aTabs);}
			if (qCard != null) {qCard.destroy();}
			if (PrevQBtn != null) {PrevQBtn.destroy();}
			if (NextQBtn != null) {NextQBtn.destroy();}
			
			qCard = stage.insert(new Q.UI.FlashCard(), qContainer);
			qCard.generate(fcQuestion);
			
			aBtns = generateAnswers();
			aTabs = generateTabs();

			if (pAnswer == "null") {
				PTimeCounter.p.label = "None";
			} else {
				PTimeCounter.p.label = (pTime / 1000).toFixed(3) + " s";
			}
			if (eAnswer == "null") {
				ETimeCounter.p.label = "None";
			} else {
				ETimeCounter.p.label = (eTime / 1000).toFixed(3) + " s";
			}
			
			
			
			QCounter.p.label = Q.state.get("battleIndex") + " / " + Q.state.get("totalIndex");
			if (pBattleCounters.length > 0) {
				for (i=0;i<pBattleCounters.length;i++) {
					pBattleCounters[i].p.opacity = passive_opacity;
				}
				pBattleCounters[Q.state.get("battleIndex") - 1].p.opacity = 1;
			}
			if (eBattleCounters.length > 0) {
				for (i=0;i<eBattleCounters.length;i++) {
					eBattleCounters[i].p.opacity = passive_opacity;
				}
				eBattleCounters[Q.state.get("battleIndex") - 1].p.opacity = 1;
			}
			
			if (Q.state.get("battleIndex") > 1) {
				PrevQBtn = stage.insert(new Q.UI.Button({
				  fill: "white",
				  fontColor: "black",
				  highlight: "gray",
				  x: ((320/4) - 30) * qx,
				  y: 535 * qy,
				  border: 2,
				  shadow: 3,
				  shadowColor: "rgba(0,0,0,0.5)",
				  w: 70 * qx,
				  h: 40 * qy,
				  label: "< P",
				}, function() {
					Q.state.inc("battleIndex", -1);
				}));
			}
			if (Q.state.get("battleIndex") < Q.state.get("totalIndex")) {
				NextQBtn = stage.insert(new Q.UI.Button({
				  fill: "white",
				  fontColor: "black",
				  highlight: "gray",
				  x: ((0.75*320) + 30) * qx,
				  y: 535 * qy,
				  border: 2,
				  shadow: 3,
				  shadowColor: "rgba(0,0,0,0.5)",
				  w: 70 * qx,
				  h: 40 * qy,
				  label: 'N >',
				}, function() {
					Q.state.inc("battleIndex", 1);
				}));
			}
		});
	
		var qContainer = stage.insert(new Q.UI.Container({
			fill: "white",
			x: 160 * qx,
			y: 160 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			w: 250 * qx,
			h: 180 * qy
		}));
		
		var PrevQBtn, NextQBtn, qCard;
		
		var QCounter = stage.insert(new Q.UI.Button({
			fill: "white",
			x: 160 * qx,
			y: 535 * qy,
			w: 120 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: ""
		}));
		
		var PTimeCounter = stage.insert(new Q.UI.Button({
			fill: "white",
			x: ((320/4) - 25) * qx,
			y: 35 * qy,
			w: 95 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: ""
		}));
		
		var ETimeCounter = stage.insert(new Q.UI.Button({
			fill: "white",
			x: ((0.75*320) + 25) * qx,
			y: 35 * qy,
			w: 95 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: ""
		}));
		
		var ReturnBtn = stage.insert(new Q.UI.Button({
			fill: "white",
			highlight: "gray",
			x: (320/2) * qx,
			y: 35 * qy,
			w: 80 * qx,
			h: 40 * qy,
			border: 2,
			shadow: 3,
			shadowColor: "rgba(0,0,0,0.5)",
			label: "Back"
		}, function() {
			Q.stageScene("scene2");
		}));
		
		var pBattleCounters = [], eBattleCounters = [];
		Q.state.inc("battleIndex", 1);
		
		for (i=0;i<Q.state.get("totalIndex");i++) {
			var battlePage = battleLibrary[i+1];
			var playerFill = "red", enemyFill = "red";
			var playerOp = passive_opacity, enemyOp = passive_opacity;
			if (battlePage.question.id == battlePage.player) {
				playerFill = "green";
			}
			if (battlePage.question.id == battlePage.enemy) {
				enemyFill = "green";
			}
			if (i == 0) {
				playerOp = 1, enemyOp = 1;
			}
			pBattleCounters[i] = stage.insert(new Q.UI.Container({
				fill: playerFill,
				opacity: playerOp,
				x: 15 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/Q.state.get("totalIndex")) - (i*(420/Q.state.get("totalIndex")))) * qy,
				h: (420/Q.state.get("totalIndex")) * qy
			}));
			
			eBattleCounters[i] = stage.insert(new Q.UI.Container({
				fill: enemyFill,
				opacity: enemyOp,
				x: 305 * qx,
				w: 15 * qx,
				border: 2,
				y: (490 - (210/Q.state.get("totalIndex")) - (i*(420/Q.state.get("totalIndex")))) * qy,
				h: (420/Q.state.get("totalIndex")) * qy
			}));
		}

		
	});
	
	// stage scene
	Q.load([PLAYER_SPRITE, ENEMY_SPRITE, BOMB_SPRITE], function() {
		Q.stageScene("scene0");
	});
     
	 //setTimeout(function(){Q.state.inc("currentIndex", 1);}, 5000);
});
	  </script>
	  <!-- <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-46324526-3', 'auto');
        ga('send', 'pageview');
    </script> -->
 </body>
</html>